unit ObjectStuff;interface	uses		Palettes, Globals, Utilities, Drawing, RoomStuff;	procedure AutoHideShow (hiding: Boolean);	procedure SetUpFields;	procedure DragObject (which: Integer);	procedure DragHandle;	procedure DragOffPalette (whatKind: Integer);	procedure CloseTools;	procedure UpdateTools;	procedure OpenTools;	procedure DoTools;	procedure BumpAPixel (hori, vert: Integer);	procedure DoObjectInfo;	function InsertObject: Boolean;implementation	const		objectInfoID = 131;{=================================}	procedure AutoHideShow (hiding: Boolean);	begin		if (hiding) then		begin			if (toolWndo <> nil) then			begin				SetPort(GrafPtr(toolWndo));				SetPt(holdCorner, toolWndo^.portRect.left, toolWndo^.portRect.top);				LocalToGlobal(holdCorner);				DisposeWindow(GrafPtr(toolWndo));				toolWndo := nil;				SetPort(GrafPtr(mainWndo));			end			else				SetPt(holdCorner, -1000, 0);		end		else		{not hiding - showing}		begin			if (holdCorner.h <> -1000) then			begin				if (inColor) then					toolWndo := GetNewCWindow(128, nil, WindowPtr(-1))				else					toolWndo := GetNewWindow(128, nil, WindowPtr(-1));				if (toolWndo = nil) then				begin					GenericAlert(kErrLoadingRes);					ExitToShell;				end;				SetPort(GrafPtr(toolWndo));				MoveWindow(toolWndo, holdCorner.h, holdCorner.v, FALSE);				ShowWindow(toolWndo);				SetWRefCon(toolWndo, 1);				UpdateTools;			end;		end;	end;{=================================}	procedure SetUpFields;		var			tempBool: Boolean;			tempAmount, tempExtra, what: Integer;	begin		what := thisRoom.theObjects[oneActive].objectIs;		case (what) of			flrVnt, ball, toastr, fshBwl: 				tempAmount := ceilingVert + 20;			extRct, upStar, dnStar: 				tempAmount := roomAt;			celVnt, celDct, drip: 				tempAmount := floorVert - 20;			candle: 			begin				tempAmount := thisRoom.theObjects[oneActive].boundRect.top - 100;				if (tempAmount < ceilingVert + 50) then					tempAmount := ceilingVert + 50;			end;			lftFan: 			begin				tempAmount := thisRoom.theObjects[oneActive].boundRect.left - 100;				if (tempAmount < 0) then					tempAmount := 0;			end;			ritFan, grease: 			begin				tempAmount := thisRoom.theObjects[oneActive].boundRect.right + 100;				if (tempAmount > 512) then					tempAmount := 512;			end;			clock, paper, bnsRct: 				tempAmount := 1000;			rbrBnd: 				tempAmount := 10;			battry: 				tempAmount := 40;			outlet, teaKtl: 				tempAmount := 120;			pwrSwt: 				tempAmount := 0;			otherwise				tempAmount := 0;		end;		case (what) of			celDct, lftFan, ritFan, grease, shredr: 				tempBool := TRUE;			otherwise				tempBool := FALSE;		end;		case (what) of			celDct: 				tempExtra := roomAt;			drip, toastr, fshBwl: 				tempExtra := 120;			otherwise				tempExtra := 0;		end;		with thisRoom.theObjects[oneActive] do		begin			objectIs := what;			amount := tempAmount;			extra := tempExtra;			isOn := tempBool;		end;	end;{=================================}	procedure DragObject;		var			floorLockOn, ceilingLockOn, stairLockOn: Boolean;			isPt, wasPt, refPt: Point;			theSrc, oldRect, destRect: Rect;			what, errorIs: Integer;	begin		SetPort(GrafPtr(mainWndo));		what := thisRoom.theObjects[which].objectIs;		destRect := thisRoom.theObjects[which].boundRect;		oldRect := destRect;		theSrc := srcRect[what];		floorLockOn := FALSE;		ceilingLockOn := FALSE;		stairLockOn := FALSE;		if (what = flrVnt) then			floorLockOn := TRUE;		if ((what = celDct) or (what = celVnt)) then			ceilingLockOn := TRUE;		if ((what = upStar) or (what = dnStar)) then			stairLockOn := TRUE;		isPt := theEvent.where;		wasPt := isPt;		PenPat(gray);		PenMode(patXOr);		FrameRect(destRect);		while (WaitMouseUp) do		begin			GetMouse(isPt);			LocalToGlobal(isPt);			if ((isPt.h <> wasPt.h) or (isPt.v <> wasPt.v)) then			begin				FrameRect(destRect);				if ((floorLockOn) or (ceilingLockOn) or (stairLockOn)) then					OffsetRect(destRect, isPt.h - wasPt.h, 0)				else					OffsetRect(destRect, isPt.h - wasPt.h, isPt.v - wasPt.v);				FrameRect(destRect);				oldRect := destRect;			end;			wasPt := isPt;		end;		FrameRect(destRect);		PenNormal;		if (toolWndo <> nil) then			SetPort(toolWndo);		changed := TRUE;		thisRoom.theObjects[which].boundRect := destRect;		if (ErrorCheckObject(thisRoom.theObjects[which], errorIs)) then			SysBeep(1);							{*** temp beep for error}	end;{=================================}	procedure DragHandle;		const			horiLock = 0;			vertLock = 1;			noLock = 2;		var			min, max, restrict, saveActive: Integer;			savePos, savePos2, min2, max2, kind: Integer;			stretchFrame: Rect;			wasPt, isPt: Point;			square: Boolean;	begin		saveActive := oneActive;		Deselect;		changed := TRUE;		SetPort(GrafPtr(mainWndo));		with thisRoom.theObjects[saveActive] do		begin			case (objectIs) of	{Pop the handle out}				table, shelf: 				begin					min := boundRect.left + 64;					max := 512;					restrict := horiLock;					square := FALSE;				end;				flrVnt, candle, toastr, ball, fshBwl: 				begin					min := ceilingVert + 20;					max := boundRect.top - 20;					restrict := vertLock;					square := FALSE;				end;				celVnt, celDct, drip: 				begin					min := boundRect.bottom + 20;					max := floorVert;					restrict := vertLock;					square := FALSE;				end;				lftFan: 				begin					min := 0;					max := boundRect.left - 20;					restrict := horiLock;					square := FALSE;				end;				ritFan, grease: 				begin					min := boundRect.right + 20;					max := 512;					restrict := horiLock;					square := FALSE;				end;				otherwise				begin					min := boundRect.left + 32;					max := 512;					min2 := boundRect.top + 32;					max2 := 342;					stretchFrame := boundRect;					square := TRUE;				end;			end;		{End of case}		end;		{End of with}		PenPat(gray);		PenMode(PatXOr);		if (square) then			FrameRect(stretchFrame)		else		begin			MoveTo(startPt.h, startPt.v);			LineTo(endPt.h, endPt.v);		end;		PaintRect(handleRect);		GetMouse(wasPt);		isPt := wasPt;		while WaitMouseUp do		begin			GetMouse(isPt);			if (square) then			begin				if ((isPt.h <> wasPt.h) or (isPt.v <> wasPt.v)) then				begin					FrameRect(stretchFrame);					PaintRect(handleRect);					savePos := endPt.h;					savePos2 := endPt.v;					endPt := isPt;					if (endPt.h > max) then						endPt.h := max;					if (endPt.h < min) then						endPt.h := min;					if (endPt.v > max2) then						endPt.v := max2;					if (endPt.v < min2) then						endPt.v := min2;					OffsetRect(handleRect, endPt.h - savePos, endPt.v - savePos2);					stretchFrame.right := endPt.h;					stretchFrame.bottom := endPt.v;					FrameRect(stretchFrame);					PaintRect(handleRect);				end;			end			else			begin				if ((restrict = horiLock) and (isPt.h <> wasPt.h)) then				begin					MoveTo(startPt.h, startPt.v);					LineTo(endPt.h, endPt.v);					PaintRect(handleRect);					savePos := endPt.h;					endPt.h := isPt.h;					if (endPt.h > max) then						endPt.h := max;					if (endPt.h < min) then						endPt.h := min;					OffsetRect(handleRect, endPt.h - savePos, 0);					MoveTo(startPt.h, startPt.v);					LineTo(endPt.h, endPt.v);					PaintRect(handleRect);				end;				if ((restrict = vertLock) and (isPt.v <> wasPt.v)) then				begin					MoveTo(startPt.h, startPt.v);					LineTo(endPt.h, endPt.v);					PaintRect(handleRect);					savePos := endPt.v;					endPt.v := isPt.v;					if (endPt.v > max) then						endPt.v := max;					if (endPt.v < min) then						endPt.v := min;					OffsetRect(handleRect, 0, endPt.v - savePos);					MoveTo(startPt.h, startPt.v);					LineTo(endPt.h, endPt.v);					PaintRect(handleRect);				end;			end;			wasPt := isPt;		end;		if (square) then			FrameRect(stretchFrame)		else		begin			MoveTo(startPt.h, startPt.v);			LineTo(endPt.h, endPt.v);		end;		PaintRect(handleRect);		PenNormal;		if (toolWndo <> nil) then			SetPort(toolWndo);		with thisRoom.theObjects[saveActive] do			case (objectIs) of				table, shelf: 					boundRect.right := wasPt.h;				cabnet, extRct, obsRct, bnsRct, window, mirror: 				begin					boundRect := stretchFrame;				end;				otherwise					if (restrict = horiLock) then						amount := endPt.h					else						amount := endPt.v;			end;		kind := thisRoom.theObjects[saveActive].objectIs;		oneActive := saveActive;		changed := TRUE;		case kind of			{some objects require a complete redrawing}			table, shelf, cabnet, extRct, obsRct, bnsRct, window, mirror: 				DrawAllObjects;			otherwise			{others are unaffected by a handle-drag}				Select;		end;	end;{=================================}	procedure DragOffPalette;		var			thePt: Point;			i: Integer;			finalRect: Rect;			wasPort: GrafPtr;	begin		GetPort(wasPort);		SetPort(GrafPtr(mainWndo));		with thisRoom do		begin			if (numberOObjects < 16) then				numberOObjects := numberOObjects + 1			else			begin				SetPort(wasPort);				GenericAlert(kErrTooManyObjects);				Exit(DragOffPalette);			end;			if (whatKind = toastr) or (whatKind = window) or (whatKind = mirror) then				for i := 1 to numberOObjects - 1 do					with theObjects[i] do						if (objectIs = whatKind) then						begin							numberOObjects := numberOObjects - 1;							SetPort(wasPort);							GenericAlert(16);							Exit(DragOffPalette);						end;			if (autoHide) then				AutoHideShow(TRUE);			oneActive := thisRoom.numberOObjects;			thisRoom.theObjects[oneActive].objectIs := whatKind;		end;	{with thisRoom do}		thePt := theEvent.where;		GlobalToLocal(thePt);		case whatKind of			table: 				SetRect(finalRect, thePt.h - 50, thePt.v - 5, thePt.h + 50, thePt.v + 4);			shelf: 				SetRect(finalRect, thePt.h - 50, thePt.v - 4, thePt.h + 50, thePt.v + 3);			cabnet: 				SetRect(finalRect, thePt.h - 50, thePt.v - 30, thePt.h + 50, thePt.v + 30);			extRct, obsRct, bnsRct: 				SetRect(finalRect, thePt.h - 32, thePt.v - 16, thePt.h + 32, thePt.v + 16);			mirror: 				SetRect(finalRect, thePt.h - 32, thePt.v - 64, thePt.h + 32, thePt.v + 64);			flrVnt: 			begin				finalRect := srcRect[whatKind];				OffsetRect(finalRect, -finalRect.left, -finalRect.top);				OffsetRect(finalRect, thePt.h, floorVert);				OffsetRect(finalRect, -(finalRect.right - finalRect.left) div 2, 0);			end;			celVnt, celDct: 			begin				finalRect := srcRect[whatKind];				OffsetRect(finalRect, -finalRect.left, -finalRect.top);				OffsetRect(finalRect, thePt.h, ceilingVert);				OffsetRect(finalRect, -(finalRect.right - finalRect.left) div 2, 0);			end;			window: 				SetRect(finalRect, thePt.h - 50, thePt.v - 60, thePt.h + 50, thePt.v + 60);			upStar, dnStar: 			begin				finalRect := srcRect[whatKind];				OffsetRect(finalRect, -finalRect.left, -finalRect.top);				OffsetRect(finalRect, thePt.h, stairVert);				OffsetRect(finalRect, -(finalRect.right - finalRect.left) div 2, 0);			end;			otherwise			begin				finalRect := srcRect[whatKind];				OffsetRect(finalRect, -finalRect.left, -finalRect.top);	{Set to 0,0}				OffsetRect(finalRect, thePt.h, thePt.v);				{Offset to cursor}				OffsetRect(finalRect, (finalRect.left - finalRect.right) div 2, (finalRect.top - finalRect.bottom) div 2);			end;		end;		thisRoom.theObjects[oneActive].boundRect := finalRect;		SetUpFields;		DragObject(oneActive);		SortObjects;		DrawAllObjects;		if (autoHide) then			AutoHideShow(FALSE);		UpdateMenuItems(editToObject);		SetPort(wasPort);	end;{=================================}	procedure CloseTools;	begin		if (toolWndo <> nil) then		begin			DisposeWindow(GrafPtr(toolWndo));			toolWndo := nil;		end;	end;{=================================}	procedure UpdateTools;		var			index, tempInt: Integer;			tempRect: Rect;			icnHand: Handle;			cicnHand: CIconHandle;			theSICN: SICNHand;			wasPort: GrafPtr;	begin		if (toolWndo = nil) then			Exit(UpdateTools);		GetPort(wasPort);		SetPort(GrafPtr(toolWndo));		PenNormal;		ForeColor(cyanColor);		MoveTo(5, 50);		LineTo(70, 50);		ForeColor(blackCOlor);		if (inColor) then		begin			for index := 0 to 5 do			begin				SpinBall;				cicnHand := GetCIcon(133 + index);				if (cicnHand <> nil) then					PlotCIcon(selectRect[index], cicnHand)				else					GenericAlert(kErrLoadingRes);				DisposCIcon(cicnHand);			end;		end		else		begin			for index := 0 to 5 do			begin				SpinBall;				theSICN := SICNHand(GetResource('SICN', 256 + index));				if (theSICN <> nil) then					PlotSICN(selectRect[index], theSICN);			end;		end;		tempRect := selectRect[setOTools];		InsetRect(tempRect, -3, -3);		PenSize(2, 2);		PenPat(black);		ForeColor(redColor);		FrameRect(tempRect);		ForeColor(blackColor);		PenNormal;		for index := 0 to 5 do		begin			SpinBall;			if (setOTools = 0) then				tempInt := index + 1			else				tempInt := index;			if (inColor) then			begin				cicnHand := GetCIcon(toolIcnId[tempInt + (8 * setOTools)]);				if (cicnHand <> nil) then					PlotCIcon(iconRect[index], cicnHand)				else					GenericAlert(kErrLoadingRes);				DisposCIcon(cicnHand);			end			else			begin				icnHand := GetIcon(toolIcnId[tempInt + (8 * setOTools)]);				if (icnHand <> nil) then					PlotIcon(iconRect[index], icnHand)				else					GenericAlert(kErrLoadingRes);			end;		end;		SetPort(wasPort);		InitCursor;	end;{=================================}	procedure OpenTools;	begin		if (toolWndo = nil) then		begin			if (inColor) then				toolWndo := GetNewCWindow(128, nil, WindowPtr(-1))			else				toolWndo := GetNewWindow(128, nil, WindowPtr(-1));			if (toolWndo = nil) then			begin				GenericAlert(kErrLoadingRes);				ExitToShell;			end;			SetPort(GrafPtr(toolWndo));			MoveWindow(toolWndo, screenBits.bounds.right - 99, 40, FALSE);			ShowWindow(toolWndo);			SetWRefCon(toolWndo, 1);			UpdateTools;		end		else			SelectWindow(toolWndo);	end;{=================================}	procedure DoTools;		var			index, what: Integer;			tempRect: Rect;			thePt: Point;	begin		if (toolWndo = nil) then			Exit(DoTools);		if (theEvent.what = MouseDown) then		begin			thePt := theEvent.where;			GlobalToLocal(thePt);			for index := 0 to 5 do				if (PtInRect(thePt, iconRect[index])) then				begin					Deselect;					changed := TRUE;					what := index + (setOTools * 8);					if (setOTools = 0) then						what := what + 1;					if (toolIcnID[what] <> 400) then						DragOffPalette(what)					else						what := 0;				end;			for index := 0 to 5 do				if (PtInRect(thePt, selectRect[index])) then					if (setOTools <> index) then					begin						tempRect := selectRect[setOTools];						InsetRect(tempRect, -3, -3);						PenSize(2, 2);						if (inColor) then						begin							RGBForeColor(rgbWhite);							FrameRect(tempRect);							RGBForeColor(rgbBlack);						end						else						begin							FrameRect(tempRect);							PenMode(patXOr);							FrameRect(tempRect);							PenNormal;						end;						setOTools := index;						UpdateTools;					end;		end;	end;{=================================}	procedure BumpAPixel;		var			holdObject, what: Integer;			destRect, theSrc: Rect;	begin		holdObject := oneActive;		Deselect;		oneActive := holdObject;		destRect := thisRoom.theObjects[oneActive].boundRect;		what := thisRoom.theObjects[oneActive].objectIs;		if (((what = flrVnt) or (what = celVnt) or (what = celDct)) and (vert <> 0)) then			vert := 0;		OffsetRect(destRect, hori, vert);{error check that bounds have been respected HERE}		theSrc := srcRect[what];		DrawAllObjects;		with thisRoom.theObjects[oneActive] do		begin			boundRect := destRect;			case objectIs of				candle, toastr..fshBwl: 				begin					amount := amount + vert;					if (amount < (ceilingVert + 20)) then						amount := ceilingVert + 20;				end;				lftFan: 				begin					amount := amount + hori;					if (amount < 0) then						amount := 0;				end;				ritFan, grease: 				begin					amount := amount + hori;					if (amount > 512) then						amount := 512;				end;				otherwise					;			end;		{case}		end;		{with}		Select;	end;{=================================}	procedure DoObjectInfo;		const			inactive = 255;			active = 0;			okayBut = 1;			cancelBut = 2;			leftEdit = 3;			topEdit = 4;			widthEdit = 5;			heightEdit = 6;			delayEdit = 7;			onRadio = 8;			offRadio = 9;			leftStat = 12;			topStat = 13;			widthStat = 14;			heightStat = 15;			delayStat = 16;			numStat = 18;		var			wasPort: GrafPtr;			leaveDlg: Boolean;			theDlgPtr: DialogPtr;			tempRect, wasRect: Rect;			cntlType, itemHit, tempInt, rightOff, downOff, i, whichSelect: Integer;			tempLong: LongInt;			dlgItem: Handle;			strTemp: Str255;			tempObject: objectData;{-------------------------}		function ReadNumber (item: Integer): Integer;		begin			GetDItem(theDlgPtr, item, cntlType, dlgItem, tempRect);			GetIText(dlgItem, strTemp);			StringToNum(strTemp, tempLong);			ReadNumber := LoWord(tempLong);		end;{-------------------------}		procedure WriteNumber (item, value: Integer; select: Boolean);		begin			GetDItem(theDlgPtr, item, cntlType, dlgItem, tempRect);			NumToString(value, strTemp);			SetIText(dlgItem, strTemp);			if (select) then				SelIText(theDlgPtr, item, 0, 4);		end;{-------------------------}		procedure Redraw;			var				width: Integer;		begin			SetPort(theDlgPtr);     		{Point to our dialog window}			GetDItem(theDlgPtr, okayBut, cntlType, dlgItem, tempRect);{Get the item handle}			PenSize(3, 3);  				{Change pen to draw thick default outline}			InsetRect(tempRect, -4, -4);     	{Draw outside the button by 1 pixel}			FrameRoundRect(tempRect, 16, 16); {Draw the outline}			PenNormal;			with theDlgPtr^.portRect do				width := right - left;			MoveTo(4, 38);			Line(width - 8, 0);			MoveTo(4, 40);			Line(width - 8, 0);		end;{-------------------------}	begin		GetPort(wasPort);		theDlgPtr := GetNewDialog(objectInfoID, nil, Pointer(-1));		with theDlgPtr^.portBits do		begin			rightOff := rightOffset - bounds.left;			downOff := downOffset - bounds.top;		end;		MoveWindow(theDlgPtr, rightOff, downOff, FALSE);		ShowWindow(theDlgPtr);		SelectWindow(theDlgPtr);		SetPort(theDlgPtr);		tempObject := thisRoom.theObjects[oneActive];		with tempObject do		begin{pop object number as static field}			WriteNumber(numStat, oneActive, FALSE);{pop left coordinate into edit text field}			WriteNumber(leftEdit, boundRect.left, FALSE);{pop top coordinate into edit text field}			WriteNumber(topEdit, boundRect.top, FALSE);			whichSelect := leftEdit;			case objectIs of				table, shelf: 				begin					WriteNumber(widthEdit, boundRect.right - boundRect.left, FALSE);					HideDItem(theDlgPtr, heightEdit);					HideDItem(theDlgPtr, heightStat);					whichSelect := widthEdit;				end;				cabNet, extRct, obsRct, bnsRct, window, mirror: 				begin					WriteNumber(widthEdit, boundRect.right - boundRect.left, FALSE);					WriteNumber(heightEdit, boundRect.bottom - boundRect.top, FALSE);					whichSelect := widthEdit;				end;				flrVnt, celVnt, upStar, dnStar: 				begin					HideDItem(theDlgPtr, topEdit);					HideDItem(theDlgPtr, topStat);					HideDItem(theDlgPtr, widthEdit);					HideDItem(theDlgPtr, widthStat);					HideDItem(theDlgPtr, heightEdit);					HideDItem(theDlgPtr, heightStat);				end;				celDct: 				begin					HideDItem(theDlgPtr, topEdit);					HideDItem(theDlgPtr, topStat);					WriteNumber(widthEdit, extra, FALSE);					GetDItem(theDlgPtr, widthStat, cntlType, dlgItem, tempRect);					SetIText(dlgItem, 'Rm # link');					HideDItem(theDlgPtr, heightEdit);					HideDItem(theDlgPtr, heightStat);					whichSelect := widthEdit;				end;				drip, toastr, fshBwl: 				begin					WriteNumber(widthEdit, extra, FALSE);					GetDItem(theDlgPtr, widthStat, cntlType, dlgItem, tempRect);					SetIText(dlgItem, 'Delay (1/60th secs)');					HideDItem(theDlgPtr, heightEdit);					HideDItem(theDlgPtr, heightStat);					whichSelect := widthEdit;				end;				otherwise				begin					HideDItem(theDlgPtr, widthEdit);					HideDItem(theDlgPtr, widthStat);					HideDItem(theDlgPtr, heightEdit);					HideDItem(theDlgPtr, heightStat);				end;			end;	{case objectIs}			case objectIs of				extRct, upStar, dnStar: 				begin					WriteNumber(delayEdit, amount, FALSE);					GetDItem(theDlgPtr, delayStat, cntlType, dlgItem, tempRect);					SetIText(dlgItem, 'Room # connected to:');					whichSelect := delayEdit;				end;				flrVnt..ritFan: 				begin					case objectIs of						flrVnt, candle: 							WriteNumber(delayEdit, boundRect.top - amount, FALSE);						celVnt, celDct: 							WriteNumber(delayEdit, amount - boundRect.bottom, FALSE);						lftFan: 							WriteNumber(delayEdit, boundRect.left - amount, FALSE);						ritFan: 							WriteNumber(delayEdit, amount - boundRect.right, FALSE);					end;					GetDItem(theDlgPtr, delayStat, cntlType, dlgItem, tempRect);					SetIText(dlgItem, 'Length of air column:');					if (objectIs <> celDct) then						whichSelect := delayEdit;				end;				drip, toastr, ball, fshBwl: 				begin					case objectIs of						toastr, ball, fshBwl: 							WriteNumber(delayEdit, boundRect.top - amount, FALSE);						drip: 							WriteNumber(delayEdit, amount - boundRect.bottom, FALSE);					end;					GetDItem(theDlgPtr, delayStat, cntlType, dlgItem, tempRect);					SetIText(dlgItem, 'Length of travel:');					whichSelect := delayEdit;				end;				outlet, teaKtl: 				begin					WriteNumber(delayEdit, amount, FALSE);					GetDItem(theDlgPtr, delayStat, cntlType, dlgItem, tempRect);					SetIText(dlgItem, 'Delay (1/60):');					whichSelect := delayEdit;				end;				clock, paper, bnsRct: 				begin					WriteNumber(delayEdit, amount, FALSE);					GetDItem(theDlgPtr, delayStat, cntlType, dlgItem, tempRect);					SetIText(dlgItem, 'Points awarded:');					whichSelect := delayEdit;				end;				rbrBnd, battry: 				begin					WriteNumber(delayEdit, amount, FALSE);					GetDItem(theDlgPtr, delayStat, cntlType, dlgItem, tempRect);					SetIText(dlgItem, 'Quantity:');					whichSelect := delayEdit;				end;				pwrSwt: 				begin					WriteNumber(delayEdit, amount, FALSE);					GetDItem(theDlgPtr, delayStat, cntlType, dlgItem, tempRect);					SetIText(dlgItem, 'Object # linked to:');					whichSelect := delayEdit;				end;				grease: 				begin					WriteNumber(delayEdit, amount - boundRect.right, FALSE);					GetDItem(theDlgPtr, delayStat, cntlType, dlgItem, tempRect);					SetIText(dlgItem, 'Length of spill:');					whichSelect := delayEdit;				end;				otherwise				begin					HideDItem(theDlgPtr, delayEdit);					HideDItem(theDlgPtr, delayStat);				end;			end;	{case objectIs}			case objectIs of				lftFan, ritFan, shredr, celDct, grease, window: 				begin					if (isOn) then						GetDItem(theDlgPtr, onRadio, cntlType, dlgItem, tempRect)					else						GetDItem(theDlgPtr, offRadio, cntlType, dlgItem, tempRect);					SetCtlValue(ControlHandle(dlgItem), 1);					if (objectIs = celDct) then					begin						GetDItem(theDlgPtr, onRadio, cntlType, dlgItem, tempRect);						SetCTitle(ControlHandle(dlgItem), 'Blower');						GetDItem(theDlgPtr, offRadio, cntlType, dlgItem, tempRect);						SetCTitle(ControlHandle(dlgItem), 'Suction');					end;					if (objectIs = grease) then					begin						GetDItem(theDlgPtr, onRadio, cntlType, dlgItem, tempRect);						SetCTitle(ControlHandle(dlgItem), 'Up');						GetDItem(theDlgPtr, offRadio, cntlType, dlgItem, tempRect);						SetCTitle(ControlHandle(dlgItem), 'Spilled');					end;					if (objectIs = window) then					begin						GetDItem(theDlgPtr, onRadio, cntlType, dlgItem, tempRect);						SetCTitle(ControlHandle(dlgItem), 'Window Open');						GetDItem(theDlgPtr, offRadio, cntlType, dlgItem, tempRect);						SetCTitle(ControlHandle(dlgItem), 'Window Closed');					end;				end;				otherwise				begin					HideDItem(theDlgPtr, onRadio);					HideDItem(theDlgPtr, offRadio);				end;			end;	{case objectIs}		end;	{end - with tempRoom do}{select the left coordinate text edit field}		SelIText(theDlgPtr, whichSelect, 0, 254);		Redraw;		leaveDlg := FALSE;		repeat			ModalDialog(nil, itemHit);			GetDItem(theDlgPtr, itemHit, cntlType, dlgItem, tempRect);			if (itemHit = okayBut) then			begin				leaveDlg := TRUE;				with tempObject do				begin					tempInt := ReadNumber(leftEdit);	{error check left coord}					if (tempInt < 0) then					begin						SysBeep(1);						WriteNumber(leftEdit, 0, TRUE);						leaveDlg := FALSE;					end					else if ((tempInt + (boundRect.right - boundRect.left)) > 512) then					begin						SysBeep(1);						WriteNumber(leftEdit, 512 - (boundRect.right - boundRect.left), TRUE);						leaveDlg := FALSE;					end					else					begin						tempInt := tempInt - boundRect.left;						boundRect.left := boundRect.left + tempInt;						boundRect.right := boundRect.right + tempInt;					end;					case objectIs of						table..obsRct, candle..macTsh: 						begin							tempInt := ReadNumber(topEdit);	{error check top coord}							if (tempInt < ceilingVert) then							begin								SysBeep(1);								WriteNumber(topEdit, ceilingVert, TRUE);								leaveDlg := FALSE;							end							else if ((tempInt + (boundRect.bottom - boundRect.top)) > floorVert) then							begin								SysBeep(1);								WriteNumber(topEdit, floorVert - (boundRect.bottom - boundRect.top), TRUE);								leaveDlg := FALSE;							end							else							begin								tempInt := tempInt - boundRect.top;								boundRect.top := boundRect.top + tempInt;								boundRect.bottom := boundRect.bottom + tempInt;							end;						end;						otherwise					end;					case objectIs of						table, shelf, cabNet, extRct, obsRct, bnsRct, window, mirror: 						begin							tempInt := ReadNumber(widthEdit);	{error check width}							if (tempInt + boundRect.left > 512) or (tempInt < 0) then							begin								SysBeep(1);								if (tempInt < 0) then									WriteNumber(widthEdit, 16, TRUE)								else									WriteNumber(widthEdit, 512 - boundRect.left, TRUE);								leaveDlg := FALSE;							end							else								boundRect.right := boundRect.left + tempInt;						end;						otherwise					end;					case objectIs of						cabNet, extRct, obsRct, bnsRct, window, mirror: 						begin							tempInt := ReadNumber(heightEdit);	{error check height}							if (boundRect.top + tempInt > floorVert) or (tempInt < 0) then							begin								SysBeep(1);								if (tempInt < 0) then									WriteNumber(heightEdit, 16, TRUE)								else									WriteNumber(heightEdit, floorVert - boundRect.top, TRUE);								leaveDlg := FALSE;							end							else								boundRect.bottom := boundRect.top + tempInt;						end;						otherwise					end;					case objectIs of						extRct, upStar, dnStar: 						begin							tempInt := ReadNumber(delayEdit);	{error check 'amount'}							if ((tempInt < 1) or (tempInt > 80)) then							begin								SysBeep(1);								WriteNumber(delayEdit, roomAt, TRUE);								leaveDlg := FALSE;							end							else								amount := tempInt;						end;						flrVnt, candle, toastr, ball, fshBwl: 						begin							tempInt := ReadNumber(delayEdit);							if (boundRect.top - tempInt < ceilingVert) then							begin								SysBeep(1);								WriteNumber(delayEdit, boundRect.top - ceilingVert, TRUE);								leaveDlg := FALSE;							end							else								amount := boundRect.top - tempInt;						end;						celVnt, celDct, drip: 						begin							tempInt := ReadNumber(delayEdit);							if (boundRect.bottom + tempInt > floorVert) then							begin								SysBeep(1);								WriteNumber(delayEdit, floorVert - boundRect.bottom, TRUE);								leaveDlg := FALSE;							end							else								amount := boundRect.bottom + tempInt;						end;						lftFan: 						begin							tempInt := ReadNumber(delayEdit);							if (boundRect.left - tempInt < 0) then							begin								SysBeep(1);								WriteNumber(delayEdit, boundRect.left, TRUE);								leaveDlg := FALSE;							end							else								amount := boundRect.left - tempInt;						end;						ritFan, grease: 						begin							tempInt := ReadNumber(delayEdit);							if (boundRect.right + tempInt > 512) then							begin								SysBeep(1);								WriteNumber(delayEdit, 512 - boundRect.right, TRUE);								leaveDlg := FALSE;							end							else								amount := boundRect.right + tempInt;						end;						clock, paper, bnsRct, battry, rbrBnd, outlet, teaKtl: 						begin							tempInt := ReadNumber(delayEdit);							if (tempInt < 0) then							begin								SysBeep(1);								WriteNumber(delayEdit, -1 * tempInt, TRUE);								leaveDlg := FALSE;							end							else								amount := tempInt;						end;						pwrSwt: 						begin							tempInt := ReadNumber(delayEdit);							if (tempInt < 0) or (tempInt > 16) then							begin								SysBeep(1);								WriteNumber(delayEdit, 0, TRUE);								leaveDlg := FALSE;							end							else								amount := tempInt;						end;						otherwise					end;					case objectIs of						celDct: 						begin							tempInt := ReadNumber(widthEdit);	{error check other}							if ((tempInt < 1) or (tempInt > 80)) then							begin								SysBeep(1);								WriteNumber(widthEdit, roomAt, TRUE);								leaveDlg := FALSE;							end							else								extra := tempInt;						end;						drip, toastr, fshBwl: 						begin							tempInt := ReadNumber(widthEdit);	{error check other}							if (tempInt < 0) then							begin								SysBeep(1);								WriteNumber(widthEdit, -1 * tempInt, TRUE);								leaveDlg := FALSE;							end							else								extra := tempInt;						end;						otherwise					end;				end;	{end - with tempObject}				if (leaveDlg) then				begin					thisRoom.theObjects[oneActive] := tempObject;					changed := TRUE;				end;			end;			if (itemHit = cancelBut) then				leaveDlg := TRUE;			if (itemHit = onRadio) then			begin				tempObject.isOn := TRUE;				GetDItem(theDlgPtr, onRadio, cntlType, dlgItem, tempRect);				SetCtlValue(ControlHandle(dlgItem), 1);				GetDItem(theDlgPtr, offRadio, cntlType, dlgItem, tempRect);				SetCtlValue(ControlHandle(dlgItem), 0);			end;			if (itemHit = offRadio) then			begin				tempObject.isOn := FALSE;				GetDItem(theDlgPtr, onRadio, cntlType, dlgItem, tempRect);				SetCtlValue(ControlHandle(dlgItem), 0);				GetDItem(theDlgPtr, offRadio, cntlType, dlgItem, tempRect);				SetCtlValue(ControlHandle(dlgItem), 1);			end;		until leaveDlg;		DisposDialog(theDlgPtr);		if (toolWndo <> nil) then			SetPort(toolWndo)		else			SetPort(wasPort);		DrawAllObjects;	end;{=================================}	function InsertObject;	begin		InsertObject := FALSE;		if (thisRoom.numberOObjects >= 16) then		begin			GenericAlert(kErrTooManyObjects);			Exit(InsertObject);		end;		Deselect;		with thisRoom do		begin			numberOObjects := numberOObjects + 1;			theObjects[numberOObjects] := scrapObject;		end;		oneActive := thisRoom.numberOObjects;		Select;		InsertObject := TRUE;	end;{=================================}end.