unit Drawing;interface	uses		Palettes, Globals, Utilities;	procedure DrawRoomNum;	procedure PlotSICN (theRect: Rect; theSICN: SICNHand);	procedure LoadABackground (whichID: Integer);	procedure DrawAllObjects;implementation{=================================}	procedure DrawRoomNum;		var			tempStr: Str255;	begin		NumToString(roomAt, tempStr);		tempStr := CONCAT(thisRoom.roomName, ' [', tempStr, ']');		SetWTitle(mainWndo, tempStr);	end;{=================================}	procedure PlotSICN;		var			state: SignedByte;			srcBits: BitMap;	begin		state := HGetState(Handle(theSICN));		HLock(Handle(theSICN));{$PUSH}		srcBits.baseAddr := Ptr(@theSICN^^);{$POP}		srcBits.rowBytes := 2;		SetRect(srcBits.bounds, 0, 0, 16, 16);		CopyBits(srcBits, GrafPtr(toolWndo)^.portBits, srcBits.bounds, theRect, srcCopy, nil);		HSetState(Handle(theSICN), state);	end;{=================================}	procedure ArrangeTiles;		var			i, panel: Integer;	begin		for i := 0 to 7 do		begin			panel := thisRoom.tileOrder[i];			if (inColor) then				CopyBits(BitMapPtr(loadCPtr^.portPixMap^)^, BitMapPtr(virginCPtr^.portPixMap^)^, tileRects[panel], tileRects[i], srcCopy, nil)			else				CopyBits(offLoadMap, offVirginMap, tileRects[panel], tileRects[i], srcCopy, nil);		end;	end;{=================================}	procedure LoadABackground;		var			refNumber: Integer;			tempByte: SignedByte;			thePict: PicHandle;	begin		if (inColor) then			SetPort(GrafPtr(loadCPtr))		else			SetPort(offLoadPort);		refNumber := OpenResFile(resourceName);		if (refNumber = -1) then		begin			CloseResFile(refNumber);			UseResFile(editorResNum);			GenericAlert(kErrGraphicsNotFound);			Exit(LoadABackground);		end;		thePict := GetPicture(whichID);		if (thePict <> nil) then		begin			tempByte := HGetState(Handle(thePict));			HLock(Handle(thePict));			DrawPicture(thePict, wholeArea);			HSetState(Handle(thePict), tempByte);		end		else		begin			case whichID of		{try to substitute}				205: 					thePict := GetPicture(201);				206: 					thePict := GetPicture(204);				207: 					thePict := GetPicture(200);				208: 					thePict := GetPicture(203);				209: 					thePict := GetPicture(200);				otherwise				begin					GenericAlert(kErrGraphicLoad);					Exit(LoadABackground);				end;			end;			if (thePict <> nil) then			begin				tempByte := HGetState(Handle(thePict));				HLock(Handle(thePict));				DrawPicture(thePict, wholeArea);				HSetState(Handle(thePict), tempByte);			end			else			begin				GenericAlert(kErrGraphicLoad);				Exit(LoadABackground);			end;			GenericAlert(kErrGraphicLoad);		end;		ReleaseResource(Handle(thePict));		CloseResFile(refNumber);		UseResFile(editorResNum);		if (toolWndo <> nil) then			SetPort(toolWndo);		ArrangeTiles;		if (inColor) then		begin			CopyBits(BitMapPtr(virginCPtr^.portPixMap^)^, BitMapPtr(loadCPtr^.portPixMap^)^, wholeArea, wholeArea, srcCopy, nil);			CopyBits(BitMapPtr(virginCPtr^.portPixMap^)^, GrafPtr(mainWndo)^.portBits, wholeArea, wholeArea, srcCopy, GrafPtr(mainWndo)^.visRgn)		end		else		begin			CopyBits(offVirginMap, offLoadMap, wholeArea, wholeArea, srcCopy, nil);			CopyBits(offVirginMap, mainWndo^.portBits, wholeArea, wholeArea, srcCopy, mainWndo^.visRgn);		end;	end;{=================================}	procedure FillNFrame (theColor: RGBColor; theRect: Rect);	begin		RGBForeColor(theColor);		PaintRect(theRect);		RGBForeColor(rgbBlack);		FrameRect(theRect);	end;{=================================}	procedure GrayNFrame (theRect: Rect);	begin		FillRect(theRect, gray);		FrameRect(theRect);	end;{=================================}	procedure HiLiteARect (theColor: RGBColor; theRect: Rect);	begin		RGBForeColor(theColor);		MoveTo(theRect.left + 1, theRect.top + 1);		LineTo(theRect.right - 2, theRect.top + 1);		LineTo(theRect.right - 2, theRect.bottom - 2);		RGBForeColor(rgbBlack);	end;{=================================}	procedure GrayLiteARect (theRect: Rect);	begin		PenPat(white);		MoveTo(theRect.left + 1, theRect.top + 1);		LineTo(theRect.right - 2, theRect.top + 1);		LineTo(theRect.right - 2, theRect.bottom - 2);		PenNormal;		MoveTo(theRect.left + 1, theRect.top + 1);		LineTo(theRect.left + 1, theRect.bottom - 2);		LineTo(theRect.right - 2, theRect.bottom - 2);	end;{=================================}	procedure LoLiteARect (theRect: Rect);	begin		RGBForeColor(rgbLtBrown);		MoveTo(theRect.left - 1, theRect.top);		LineTo(theRect.left - 1, theRect.bottom);		LineTo(theRect.right - 1, theRect.bottom);		RGBForeColor(rgbDkGray);		MoveTo(theRect.left, theRect.top - 1);		LineTo(theRect.right, theRect.top - 1);		LineTo(theRect.right, theRect.bottom);		RGBForeColor(rgbBlack);	end;{=================================}	procedure GrayLoARect (theRect: Rect);	begin		PenPat(white);		MoveTo(theRect.left - 1, theRect.top);		LineTo(theRect.left - 1, theRect.bottom);		LineTo(theRect.right - 1, theRect.bottom);		PenNormal;		MoveTo(theRect.left, theRect.top - 1);		LineTo(theRect.right, theRect.top - 1);		LineTo(theRect.right, theRect.bottom);	end;{=================================}	procedure DrawTable (whichItem: Integer);		var			kind: Integer;			theRect, tempRect: Rect;	begin		if (inColor) then			SetPort(GrafPtr(loadCPtr))		else			SetPort(offLoadPort);		PenNormal;		with thisRoom.theObjects[whichItem] do		begin			kind := objectIs;			theRect := boundRect;		end;		if (inColor) then	{***** Draw table top}		begin			FillNFrame(rgbBrown, theRect);			MoveTo(theRect.left + 1, theRect.bottom - 2);			LineTo(theRect.right - 1, theRect.bottom - 2);			HiLiteARect(rgbLtBrown, theRect);		end		else		begin			GrayNFrame(theRect);			GrayLiteARect(theRect);		end;		PenNormal;				{***** Draw table shadow}		SetRect(tempRect, theRect.left, floorVert - 0, theRect.right, floorVert + 20);		OffsetRect(tempRect, (theRect.top - floorVert) div 5, 0);		if (inColor) then		begin			PenMode(patCopy + transparent);			PenPat(gray);			PaintOval(tempRect);		end		else		begin			PenMode(patOr);			PenPat(gray);			PaintOval(tempRect);		end;		PenNormal;		if (inColor) then			{***** Draw table support}		begin			RGBForeColor(rgbBlack);			PenSize(5, 1);			MoveTo(((theRect.left + theRect.right) div 2) - 2, theRect.bottom);			LineTo(((theRect.left + theRect.right) div 2) - 2, floorVert - 7);			RGBForeColor(rgbWhite);			PenSize(1, 1);			MoveTo(((theRect.left + theRect.right) div 2) + 1, theRect.bottom + (theRect.right - theRect.left) div 8);			LineTo(((theRect.left + theRect.right) div 2) + 1, floorVert - 7);			RGBForeColor(rgbLtBrown);			MoveTo(((theRect.left + theRect.right) div 2) + 0, theRect.bottom + (theRect.right - theRect.left) div 8);			LineTo(((theRect.left + theRect.right) div 2) + 0, floorVert - 7);			RGBForeColor(rgbBlack);		end		else		begin			PenSize(5, 1);			MoveTo(((theRect.left + theRect.right) div 2) - 2, theRect.bottom);			LineTo(((theRect.left + theRect.right) div 2) - 2, floorVert - 7);			PenPat(white);			PenSize(1, 1);			MoveTo(((theRect.left + theRect.right) div 2) + 1, theRect.bottom + (theRect.right - theRect.left) div 8);			LineTo(((theRect.left + theRect.right) div 2) + 1, floorVert - 7);			PenPat(gray);			MoveTo(((theRect.left + theRect.right) div 2) + 0, theRect.bottom + (theRect.right - theRect.left) div 8);			LineTo(((theRect.left + theRect.right) div 2) + 0, floorVert - 7);		end;		PenNormal;		tempRect := srcRect[kind];{***** Draw table base}		OffsetRect(tempRect, -tempRect.left, -tempRect.top);		OffsetRect(tempRect, ((theRect.left + theRect.right) div 2) - 31, floorVert - 7);		if (inColor) then			CopyMask(BitMapPtr(objectCPtr^.portPixMap^)^, offMaskMap, BitMapPtr(loadCPtr^.portPixMap^)^, srcRect[kind], srcRect[kind], tempRect)		else			CopyMask(offPlayerMap, offMaskMap, offLoadMap, srcRect[kind], srcRect[kind], tempRect);	end;{=================================}	procedure DrawShelf (whichItem: Integer);		var			kind: Integer;			theRect, tempRect: Rect;			tempRgn: RgnHandle;	begin		if (inColor) then			SetPort(GrafPtr(loadCPtr))		else			SetPort(offLoadPort);		PenNormal;		with thisRoom.theObjects[whichItem] do		begin			kind := objectIs;			theRect := boundRect;		end;		if (inColor) then		{***** Draw shelf top}		begin			RGBForeColor(rgbLtBrown);			PaintRect(theRect);			FrameRect(theRect);			MoveTo(theRect.left + 1, theRect.bottom - 2);			LineTo(theRect.right - 1, theRect.bottom - 2);			RGBForeColor(rgbWhite);			MoveTo(theRect.left + 1, theRect.top + 1);			LineTo(theRect.right - 2, theRect.top + 1);		end		else		begin			GrayNFrame(theRect);			GrayLiteARect(theRect);		end;		PenNormal;		tempRgn := NewRgn;				{***** Draw shelf shadow}		MoveTo(theRect.right, theRect.bottom - 1);		OpenRgn;		Line(-15, 15);		LineTo(theRect.left - 15, theRect.bottom + 14);		Line(0, -5);		Line(15, -15);		Line(0, 5);		LineTo(theRect.right, theRect.bottom - 1);		CloseRgn(tempRgn);		PenPat(gray);		if (inColor) then		begin			RGBForeColor(rgbBlack);			PenMode(patCopy + transparent);			PenPat(gray);			PaintRgn(tempRgn);		end		else		begin			PenMode(patOr);			PaintRgn(tempRgn);		end;		DisposeRgn(tempRgn);		PenNormal;		tempRect := srcRect[kind];	{***** Draw shelf bracket 1}		OffsetRect(tempRect, -tempRect.left, -tempRect.top);	{0 it out}		OffsetRect(tempRect, theRect.left + 15, theRect.bottom - 2);		if (inColor) then			CopyMask(BitMapPtr(objectCPtr^.portPixMap^)^, offMaskMap, BitMapPtr(loadCPtr^.portPixMap^)^, srcRect[kind], srcRect[kind], tempRect)		else			CopyMask(offPlayerMap, offMaskMap, offLoadMap, srcRect[kind], srcRect[kind], tempRect);		tempRect := srcRect[kind];	{***** Draw shelf bracket 2}		OffsetRect(tempRect, -tempRect.left, -tempRect.top);	{0 it out}		OffsetRect(tempRect, theRect.right - 25, theRect.bottom - 2);		if (inColor) then			CopyMask(BitMapPtr(objectCPtr^.portPixMap^)^, offMaskMap, BitMapPtr(loadCPtr^.portPixMap^)^, srcRect[kind], srcRect[kind], tempRect)		else			CopyMask(offPlayerMap, offMaskMap, offLoadMap, srcRect[kind], srcRect[kind], tempRect);	end;{=================================}	procedure DrawMirror (whichItem: Integer);		var			theRect: Rect;	begin		if (inColor) then			SetPort(GrafPtr(loadCPtr))		else			SetPort(offLoadPort);		PenNormal;		with thisRoom.theObjects[whichItem] do			theRect := boundRect;		if (inColor) then		begin			FillNFrame(rgbBrown, theRect);			HiLiteARect(rgbLtBrown, theRect);		end		else		begin			GrayNFrame(theRect);			GrayLiteARect(theRect);		end;		InsetRect(theRect, 3, 3);		FillRect(theRect, white);		FrameRect(theRect);		PenNormal;	end;{=================================}	procedure DrawCabinet (whichItem: Integer);		var			panels, width, index, offIt: Integer;			theRect, tempR: Rect;			shadoRgn: RgnHandle;	begin		if (inColor) then			SetPort(GrafPtr(loadCPtr))		else			SetPort(offLoadPort);		PenNormal;		with thisRoom.theObjects[whichItem] do			theRect := boundRect;		tempR := theRect;		if (theRect.bottom > 280) then	{*** If the cabnet is a counter}		begin			tempR.bottom := tempR.bottom - 5;	{*** Paint bulk of counter}			if (inColor) then				FillNFrame(rgbBrown, tempR)			else				GrayNFrame(tempR);			tempR := theRect;				{*** Paint foot-kick on bottom}			InsetRect(tempR, 2, 0);			tempR.top := tempR.bottom - 5;			if (inColor) then				FillNFrame(rgbDkGray, tempR)			else			begin				FillRect(tempR, dkGray);				FrameRect(tempR);			end;						{*** Paint counter-top}			SetRect(tempR, theRect.left - 2, theRect.top, theRect.right + 2, theRect.top + 7);			if (inColor) then				FillNFrame(rgbLtBrown, tempR)			else			begin				FillRect(tempR, ltGray);				FrameRect(tempR);			end;			MoveTo(tempR.left + 2, tempR.bottom);			LineTo(tempR.right - 3, tempR.bottom);			shadoRgn := NewRgn;			{*** Paint counter shadow}			MoveTo(theRect.left, theRect.top + 5);			OpenRgn;			Line(-15, 15);			LineTo(theRect.left - 15, theRect.bottom - 10);			LineTo(theRect.left, theRect.bottom);			LineTo(theRect.left, theRect.top + 5);			CloseRgn(shadoRgn);			HLock(Handle(shadoRgn));			if (inColor) then			begin				RGBForeColor(rgbBlack);				PenMode(patCopy + transparent);				PenPat(gray);				PaintRgn(shadoRgn);			end			else			begin				PenMode(patOr);				PenPat(gray);				PaintRgn(shadoRgn);			end;			HUnlock(Handle(shadoRgn));			DisposeRgn(shadoRgn);			PenNormal;			offIt := 5;		end		else							{*** It's a cabinet}		begin			if (inColor) then				{*** Paint bulk of cabinet}				FillNFrame(rgbBrown, theRect)			else				GrayNFrame(theRect);			shadoRgn := NewRgn;			{*** Paint the shadow}			MoveTo(theRect.left, theRect.top);			OpenRgn;			Line(-15, 15);			LineTo(theRect.left - 15, theRect.bottom + 15);			LineTo(theRect.right - 15, theRect.bottom + 15);			Line(15, -15);			LineTo(theRect.left, theRect.bottom);			LineTo(theRect.left, theRect.top);			CloseRgn(shadoRgn);			HLock(Handle(shadoRgn));			if (inColor) then			begin				PenMode(srcCopy + transparent);				PenPat(gray);				PaintRgn(shadoRgn);			end			else			begin				PenMode(patOr);				PenPat(gray);				PaintRgn(shadoRgn);			end;			HUnlock(Handle(shadoRgn));			DisposeRgn(shadoRgn);			PenNormal;			offIt := 0;		end;		panels := (theRect.right - theRect.left) div 48;		if (panels = 0) then		begin			tempR := theRect;			InsetRect(tempR, 5, 5 + offIt);			FrameRect(tempR);			if (inColor) then			begin				RGBForeColor(rgbLtBrown);				MoveTo(tempR.left + 3, tempR.top + 3);				LineTo(tempR.left + 3, tempR.bottom - 4);				LineTo(tempR.right - 4, tempR.bottom - 4);				RGBForeColor(rgbBlack);				LineTo(tempR.right - 4, tempR.top + 3);				LineTo(tempR.left + 3, tempR.top + 3);			end			else			begin				PenPat(white);				MoveTo(tempR.left + 3, tempR.top + 3);				LineTo(tempR.left + 3, tempR.bottom - 4);				LineTo(tempR.right - 4, tempR.bottom - 4);				PenPat(black);				LineTo(tempR.right - 4, tempR.top + 3);				LineTo(tempR.left + 3, tempR.top + 3);			end;		end		else		begin			width := ((theRect.right - theRect.left) - (panels + 1) * 5) div panels;			SetRect(tempR, theRect.left + 5, theRect.top + 5 + offIt, theRect.left + 5 + width, theRect.bottom - 5 - offIt);			for index := 1 to panels do			begin				if (inColor) then				begin					RGBForeColor(rgbLtBrown);					MoveTo(tempR.left + 3, tempR.top + 3);					LineTo(tempR.left + 3, tempR.bottom - 4);					LineTo(tempR.right - 4, tempR.bottom - 4);					RGBForeColor(rgbBlack);					LineTo(tempR.right - 4, tempR.top + 3);					LineTo(tempR.left + 3, tempR.top + 3);				end				else				begin					FrameRect(tempR);					PenPat(white);					MoveTo(tempR.left + 3, tempR.top + 3);					LineTo(tempR.left + 3, tempR.bottom - 4);					LineTo(tempR.right - 4, tempR.bottom - 4);					PenPat(black);					LineTo(tempR.right - 4, tempR.top + 3);					LineTo(tempR.left + 3, tempR.top + 3);				end;				OffsetRect(tempR, width + 5, 0);			end;		end;		PenNormal;	end;{=================================}	procedure DrawARect (whichItem: Integer; popAmount: Boolean);		var			tempStr: Str255;			theRect: Rect;			number: Integer;	begin		if (inColor) then			SetPort(GrafPtr(loadCPtr))		else			SetPort(offLoadPort);		PenNormal;		with thisRoom.theObjects[whichItem] do		begin			number := amount;			theRect := boundRect;		end;		PenPat(gray);		FrameRect(theRect);		PenNormal;		if (popAmount) then		begin			PenMode(srcOr);			MoveTo(theRect.left + 2, theRect.bottom - 2);			NumToString(number, tempStr);			DrawString(tempStr);			PenNormal;		end;	end;{=================================}	procedure DrawWindow (whichItem: Integer);		var			theRect, tempRect: Rect;			kind: Integer;			tempRgn: RgnHandle;			windowOpen: Boolean;	begin		if (inColor) then			SetPort(GrafPtr(loadCPtr))		else			SetPort(offLoadPort);		PenNormal;		with thisRoom.theObjects[whichItem] do		begin			kind := objectIs;			theRect := boundRect;			windowOpen := isOn;		end;		tempRgn := NewRgn;				{***** Draw window shadow}		MoveTo(theRect.left, theRect.top);		OpenRgn;		Line(-10, 10);		Line(0, 5);		Line(5, 5);		LineTo(theRect.left - 5, theRect.bottom - 10);		Line(-5, 5);		Line(0, 5);		Line(5, 5);		LineTo(theRect.right - 5, theRect.bottom + 5);		LineTo(theRect.right, theRect.bottom);		LineTo(theRect.left, theRect.bottom);		LineTo(theRect.left, theRect.top);		CloseRgn(tempRgn);		PenPat(gray);		if (inColor) then		begin			RGBForeColor(rgbBlack);			PenMode(patCopy + transparent);			PenPat(gray);			PaintRgn(tempRgn);		end		else		begin			PenMode(patOr);			PaintRgn(tempRgn);		end;		DisposeRgn(tempRgn);		PenNormal;		if (inColor) then		begin			FillNFrame(rgbBrown, theRect);	{***** Draw window frame and sill}			HiLiteARect(rgbLtBrown, theRect);			SetRect(tempRect, theRect.left - 4, theRect.top, theRect.right + 4, theRect.top + 6);			FillNFrame(rgbBrown, tempRect);			HiLiteARect(rgbLtBrown, tempRect);			SetRect(tempRect, theRect.left - 2, theRect.top + 6, theRect.right + 2, theRect.top + 10);			FillNFrame(rgbBrown, tempRect);			SetRect(tempRect, theRect.left - 4, theRect.bottom - 6, theRect.right + 4, theRect.bottom);			FillNFrame(rgbBrown, tempRect);			HiLiteARect(rgbLtBrown, tempRect);			SetRect(tempRect, theRect.left - 2, theRect.bottom - 10, theRect.right + 2, theRect.bottom - 5);			FillNFrame(rgbBrown, tempRect);			HiLiteARect(rgbLtBrown, tempRect);			tempRect := theRect;			InsetRect(tempRect, 8, 16);			FillNFrame(rgbBrown, tempRect);			LoLiteARect(tempRect);			tempRect := theRect;			{***** Draw the top window pane}			InsetRect(tempRect, 8, 16);			tempRect.bottom := ((theRect.bottom + theRect.top) div 2) + 2;			FillNFrame(rgbBrown, tempRect);			InsetRect(tempRect, 6, 6);			LoLiteARect(tempRect);			InsetRect(tempRect, 2, 2);			LoLiteARect(tempRect);			InsetRect(tempRect, 2, 2);			FillNFrame(rgbBlack, tempRect);			LoLiteARect(tempRect);			tempRect := theRect;			{Fill bottom black}			InsetRect(tempRect, 8, 16);			tempRect.top := ((theRect.bottom + theRect.top) div 2) + 2;			FillRect(tempRect, black);			tempRect := theRect;			{***** Draw the bottom window pane}			InsetRect(tempRect, 8, 16);			tempRect.top := ((theRect.bottom + theRect.top) div 2) - 2;			if (windowOpen) then				OffsetRect(tempRect, 0, 26 - ((theRect.bottom - theRect.top) div 2));			FillNFrame(rgbBrown, tempRect);			InsetRect(tempRect, 6, 6);			LoLiteARect(tempRect);			InsetRect(tempRect, 2, 2);			LoLiteARect(tempRect);			InsetRect(tempRect, 2, 2);			FillNFrame(rgbBlack, tempRect);			LoLiteARect(tempRect);			RGBForeColor(rgbBlack);		end		else		begin			GrayNFrame(theRect);	{***** Draw window frame and sill}			GrayLiteARect(theRect);			SetRect(tempRect, theRect.left - 4, theRect.top, theRect.right + 4, theRect.top + 6);			GrayNFrame(tempRect);			GrayLiteARect(tempRect);			SetRect(tempRect, theRect.left - 2, theRect.top + 6, theRect.right + 2, theRect.top + 10);			GrayNFrame(tempRect);			SetRect(tempRect, theRect.left - 4, theRect.bottom - 6, theRect.right + 4, theRect.bottom);			GrayNFrame(tempRect);			GrayLiteARect(tempRect);			SetRect(tempRect, theRect.left - 2, theRect.bottom - 10, theRect.right + 2, theRect.bottom - 5);			GrayNFrame(tempRect);			GrayLiteARect(tempRect);			tempRect := theRect;			InsetRect(tempRect, 8, 16);			GrayNFrame(tempRect);			GrayLoARect(tempRect);			tempRect := theRect;			{***** Draw the top window pane}			InsetRect(tempRect, 8, 16);			tempRect.bottom := ((theRect.bottom + theRect.top) div 2) + 2;			GrayNFrame(tempRect);			InsetRect(tempRect, 6, 6);			GrayLoARect(tempRect);			InsetRect(tempRect, 2, 2);			GrayLoARect(tempRect);			InsetRect(tempRect, 2, 2);			FillRect(tempRect, black);			GrayLoARect(tempRect);			tempRect := theRect;			{Fill bottom black}			InsetRect(tempRect, 8, 16);			tempRect.top := ((theRect.bottom + theRect.top) div 2) + 2;			FillRect(tempRect, black);			tempRect := theRect;			{***** Draw the bottom window pane}			InsetRect(tempRect, 8, 16);			tempRect.top := ((theRect.bottom + theRect.top) div 2) - 2;			if (windowOpen) then				OffsetRect(tempRect, 0, 26 - ((theRect.bottom - theRect.top) div 2));			GrayNFrame(tempRect);			InsetRect(tempRect, 6, 6);			GrayLoARect(tempRect);			InsetRect(tempRect, 2, 2);			GrayLoARect(tempRect);			InsetRect(tempRect, 2, 2);			FillRect(tempRect, black);			GrayLoARect(tempRect);		end;	end;{=================================}	procedure DrawStair (whichItem: Integer);		var			refNumber, kind: Integer;			tempByte: SignedByte;			theRect: Rect;			thePict: PicHandle;	begin		if (inColor) then			SetPort(GrafPtr(loadCPtr))		else			SetPort(offLoadPort);		with thisRoom.theObjects[whichItem] do		begin			kind := objectIs;			theRect := boundRect;		end;		refNumber := OpenResFile(resourceName);		if (refNumber = -1) then		begin			CloseResFile(refNumber);			UseResFile(editorResNum);			GenericAlert(kErrGraphicsNotFound);			Exit(DrawStair);		end;		if (kind = upStar) then			thePict := GetPicture(198)		else			thePict := GetPicture(199);		if (thePict <> nil) then		begin			tempByte := HGetState(Handle(thePict));			HLock(Handle(thePict));			DrawPicture(thePict, theRect);			HSetState(Handle(thePict), tempByte);		end		else		begin			GenericAlert(kErrGraphicLoad);		end;		ReleaseResource(Handle(thePict));		CloseResFile(refNumber);		UseResFile(editorResNum);	end;{=================================}	procedure DrawAllObjects;		var			wasPort: GrafPtr;			index, nObjects, holdSelect: Integer;			theSrc, destRect: Rect;	begin		GetPort(wasPort);		nObjects := thisRoom.numberOObjects;		if (nObjects = 0) then		begin			if (inColor) then				CopyBits(BitMapPtr(virginCPtr^.portPixMap^)^, GrafPtr(mainWndo)^.portBits, wholeArea, wholeArea, srcCopy, GrafPtr(mainWndo)^.visRgn)			else				CopyBits(offVirginMap, mainWndo^.portBits, wholeArea, wholeArea, srcCopy, mainWndo^.visRgn);			Exit(DrawAllObjects);		end;		if (lightsOut) then		begin			if (inColor) then				SetPort(GrafPtr(loadCPtr))			else				SetPort(offLoadPort);			PenNormal;			PaintRect(wholeArea);			for index := 1 to thisRoom.numberOObjects do				with thisRoom.theObjects[index] do					if (objectIs = litSwt) then					begin						theSrc := srcRect[objectIs];						destRect := boundRect;						if (inColor) then							CopyMask(BitMapPtr(objectCPtr^.portPixMap^)^, offMaskMap, BitMapPtr(loadCPtr^.portPixMap^)^, theSrc, theSrc, destRect)						else							CopyMask(offPlayerMap, offMaskMap, offLoadMap, theSrc, theSrc, destRect);					end;			if (inColor) then				CopyBits(BitMapPtr(loadCPtr^.portPixMap^)^, GrafPtr(mainWndo)^.portBits, wholeArea, wholeArea, srcCopy, GrafPtr(mainWndo)^.visRgn)			else				CopyBits(offLoadMap, mainWndo^.portBits, wholeArea, wholeArea, srcCopy, mainWndo^.visRgn);			Exit(DrawAllObjects);		end;		holdSelect := oneActive;		if (holdSelect <> 0) then			Deselect;		if (inColor) then			CopyBits(BitMapPtr(virginCPtr^.portPixMap^)^, BitMapPtr(loadCPtr^.portPixMap^)^, wholeArea, wholeArea, srcCopy, wholeRgn)		else			CopyBits(offVirginMap, offLoadMap, wholeArea, wholeArea, srcCopy, wholeRgn);		for index := 1 to thisRoom.numberOObjects do			with thisRoom.theObjects[index] do				case objectIs of					table: 						DrawTable(index);					shelf: 						DrawShelf(index);					cabNet: 						DrawCabinet(index);					books: 					begin						theSrc := srcRect[objectIs];						destRect := boundRect;						if (inColor) then							CopyMask(BitMapPtr(objectCPtr^.portPixMap^)^, offMaskMap, BitMapPtr(loadCPtr^.portPixMap^)^, theSrc, theSrc, destRect)						else							CopyMask(offPlayerMap, offMaskMap, offLoadMap, theSrc, theSrc, destRect);					end;					extRct, bnsRct: 						DrawArect(index, TRUE);					obsRct: 						DrawArect(index, FALSE);					flrVnt..candle: 					begin						theSrc := srcRect[objectIs];						destRect := boundRect;						if (inColor) then							CopyMask(BitMapPtr(objectCPtr^.portPixMap^)^, offMaskMap, BitMapPtr(loadCPtr^.portPixMap^)^, theSrc, theSrc, destRect)						else							CopyMask(offPlayerMap, offMaskMap, offLoadMap, theSrc, theSrc, destRect);					end;					lftFan, ritFan: 					begin						theSrc := srcRect[objectIs];						destRect := boundRect;						if (inColor) then							CopyMask(BitMapPtr(objectCPtr^.portPixMap^)^, offMaskMap, BitMapPtr(loadCPtr^.portPixMap^)^, theSrc, theSrc, destRect)						else							CopyMask(offPlayerMap, offMaskMap, offLoadMap, theSrc, theSrc, destRect);					end;					grease: 					begin						if (isOn) then							theSrc := srcRect[objectIs]	{grease is up}						else							theSrc := srcRect[59];		{grease has fallen}						destRect := boundRect;						if (inColor) then							CopyMask(BitMapPtr(objectCPtr^.portPixMap^)^, offMaskMap, BitMapPtr(loadCPtr^.portPixMap^)^, theSrc, theSrc, destRect)						else							CopyMask(offPlayerMap, offMaskMap, offLoadMap, theSrc, theSrc, destRect);					end;					clock, paper, battry, rbrBnd: 					begin						theSrc := srcRect[objectIs];						destRect := boundRect;						if (inColor) then							CopyMask(BitMapPtr(objectCPtr^.portPixMap^)^, offMaskMap, BitMapPtr(loadCPtr^.portPixMap^)^, theSrc, theSrc, destRect)						else							CopyMask(offPlayerMap, offMaskMap, offLoadMap, theSrc, theSrc, destRect);					end;					litSwt..guitar: 					begin						theSrc := srcRect[objectIs];						destRect := boundRect;						if (inColor) then							CopyMask(BitMapPtr(objectCPtr^.portPixMap^)^, offMaskMap, BitMapPtr(loadCPtr^.portPixMap^)^, theSrc, theSrc, destRect)						else							CopyMask(offPlayerMap, offMaskMap, offLoadMap, theSrc, theSrc, destRect);					end;					toastr..teaKtl: 					begin						theSrc := srcRect[objectIs];						destRect := boundRect;						if (inColor) then							CopyMask(BitMapPtr(objectCPtr^.portPixMap^)^, offMaskMap, BitMapPtr(loadCPtr^.portPixMap^)^, theSrc, theSrc, destRect)						else							CopyMask(offPlayerMap, offMaskMap, offLoadMap, theSrc, theSrc, destRect);					end;					drip: 					begin						theSrc := srcRect[objectIs];						destRect := boundRect;						if (inColor) then							CopyMask(BitMapPtr(objectCPtr^.portPixMap^)^, offMaskMap, BitMapPtr(loadCPtr^.portPixMap^)^, theSrc, theSrc, destRect)						else							CopyMask(offPlayerMap, offMaskMap, offLoadMap, theSrc, theSrc, destRect);					end;					window: 						DrawWindow(index);					mirror: 						DrawMirror(index);					paintg: 					begin						theSrc := srcRect[objectIs];						destRect := boundRect;						if (inColor) then							CopyBits(BitMapPtr(objectCPtr^.portPixMap^)^, BitMapPtr(loadCPtr^.portPixMap^)^, theSrc, destRect, srcCopy, nil)						else							CopyBits(offPlayerMap, offLoadMap, theSrc, destRect, srcCopy, nil);					end;					basket, macTsh: 					begin						theSrc := srcRect[objectIs];						destRect := boundRect;						if (inColor) then							CopyMask(BitMapPtr(objectCPtr^.portPixMap^)^, offMaskMap, BitMapPtr(loadCPtr^.portPixMap^)^, theSrc, theSrc, destRect)						else							CopyMask(offPlayerMap, offMaskMap, offLoadMap, theSrc, theSrc, destRect);					end;					upStar, dnStar: 						DrawStair(index);					otherwise						Cycle;				end;		if (inColor) then			CopyBits(BitMapPtr(loadCPtr^.portPixMap^)^, GrafPtr(mainWndo)^.portBits, wholeArea, wholeArea, srcCopy, GrafPtr(mainWndo)^.visRgn)		else			CopyBits(offLoadMap, mainWndo^.portBits, wholeArea, wholeArea, srcCopy, mainWndo^.visRgn);		if (holdSelect <> 0) then		begin			oneActive := holdSelect;			Select;		end;		if (toolWndo <> nil) then			SetPort(toolWndo)		else			SetPort(wasPort);	end;{=================================}end.