unit TheMenus;interface	uses		Balloons, Palettes, About, Globals, Utilities, Drawing, HouseStuff, RoomStuff, ObjectStuff, FileInNOut, FlyGlider;	procedure DoNewHouse;	procedure DoOpenHouse;	procedure DoPrevRoom;	procedure DoNextRoom;	procedure DoNewRoom;	function DoSaveHouse: Boolean;	function DoSaveHouseAs: Boolean;	procedure DoClear;	procedure HandleMenu (theMenu, theItem: integer);{=================================}implementation{=================================}	procedure DoTest;	begin	end;{=================================}	procedure DoOpenHouse;		var			canceled: Boolean;	begin		if (not DoOpen) then		begin			DoNewHouse;			Exit(DoOpenHouse);		end;		ErrorCheckHouse;		changed := FALSE;		roomAt := 1;		thisRoom := thisHouse.theRooms[roomAt];		EnableItem(GetMenu(mFile), iSave);		EnableItem(GetMenu(mFile), iSaveAs);		oneActive := 0;		handleRect := nullRect;		LoadABackground(thisRoom.backPictID);		UpdateMenuItems(fileExists);		UpdateMenuItems(editToRoom);		DrawAllObjects;		DrawRoomNum;		OpenTools;	end;{=================================}	procedure DoNewHouse;		var			cancelIt: Boolean;			index: Integer;	begin		roomAt := 1;		FlushRoom(thisRoom);		with thisHouse do		begin			version := $0100;			numberORooms := 0;			for index := 0 to 19 do			begin				hiScores[index] := 0;				hiLevel[index] := 0;				hiName[index] := 'no one...';				hiRoom[index] := 'no room...';			end;			pictFile := resourceName;			nextFile := '';			firstFile := '';			theRooms[roomAt] := thisRoom;		end;		changed := FALSE;		oneActive := 0;		handleRect := nullRect;		thisHouse.numberORooms := 1;		cancelIt := FALSE;		DoRoomBackInfo(cancelIt);		LoadABackground(thisRoom.backPictID);		UpdateMenuItems(fileIsNew);		UpdateMenuItems(editToRoom);		OpenTools;	end;{=================================}	procedure DoMenuClose;		const			saveBut = 1;			cancelBut = 6;		var			buttonClicked: Integer;			dummyBool: Boolean;	begin		Deselect;		if (changed) then		begin			buttonClicked := SaveNoClose;			if (buttonClicked = saveBut) then			begin				thisHouse.theRooms[roomAt] := thisRoom;				if (fileIsOpen) then				begin					if (not DoSaveHouse) then					begin						dummyBool := DoClose;						Exit(DoMenuClose);					end;					dummyBool := DoClose;				end				else				begin					if (not DoSaveHouseAs) then						Exit(DoMenuClose);				end;			end			else if (buttonClicked = cancelBut) then			begin				Exit(DoMenuClose);			end			else				dummyBool := DoClose;		end		else			dummyBool := DoClose;		FlushRoom(thisRoom);		roomAt := 0;		changed := FALSE;		SetPort(GrafPtr(mainWndo));		EraseRect(wholeArea);		if (inColor) then			SetPort(GrafPtr(loadCPtr))		else			SetPort(offLoadPort);		EraseRect(wholeArea);		if (inColor) then			SetPort(GrafPtr(virginCPtr))		else			SetPort(offVirginPort);		EraseRect(wholeArea);		CloseTools;		UpdateMenuItems(noFileOpen);	end;{=================================}	procedure DoGoToRoom;		var			wasRoom: Integer;	begin		thisHouse.theRooms[roomAt] := thisRoom;		wasRoom := roomAt;		DoGotoDial;		if (wasRoom <> roomAt) then		begin			thisRoom := thisHouse.theRooms[roomAt];			Deselect;			LoadABackground(thisRoom.backPictID);			DrawAllObjects;			DrawRoomNum;			UpdateMenuItems(editToRoom);		end;	end;{=================================}	procedure DoPrevRoom;	begin		thisHouse.theRooms[roomAt] := thisRoom;		roomAt := roomAt - 1;		if (roomAt < 1) then			roomAt := thisHouse.numberORooms;		thisRoom := thisHouse.theRooms[roomAt];		Deselect;		LoadABackground(thisRoom.backPictID);		DrawAllObjects;		DrawRoomNum;		UpdateMenuItems(editToRoom);	end;{=================================}	procedure DoNextRoom;	begin		thisHouse.theRooms[roomAt] := thisRoom;		roomAt := roomAt + 1;		if (roomAt > thisHouse.numberORooms) then			roomAt := 1;		thisRoom := thisHouse.theRooms[roomAt];		Deselect;		LoadABackground(thisRoom.backPictID);		DrawAllObjects;		DrawRoomNum;		UpdateMenuItems(editToRoom);	end;{=================================}	procedure DoNewRoom;		var			cancelIt: Boolean;	begin		thisHouse.theRooms[roomAt] := thisRoom;		if (not InsertNewRoom) then		begin			Exit(DoNewRoom);		end;		cancelIt := TRUE;		changed := TRUE;		DoRoomBackInfo(cancelIt);		LoadABackground(thisRoom.backPictID);		DrawRoomNum;		oneActive := 0;		UpdateMenuItems(editToRoom);	end;{=================================}	function DoSaveHouse;		var			dummyBool: Boolean;	begin		thisHouse.theRooms[roomAt] := thisRoom;		ErrorCheckHouse;		dummyBool := DoSave;		DoSaveHouse := dummyBool;	end;{=================================}	function DoSaveHouseAs;		var			dummyBool: Boolean;	begin		thisHouse.theRooms[roomAt] := thisRoom;		ErrorCheckHouse;		dummyBool := DoSaveAs;		DoSaveHouseAs := dummyBool;	end;{=================================}	procedure DoQuit;		const			saveBut = 1;			quitBut = 2;			cancelBut = 6;		var			buttonClicked: Integer;			dummyBool: Boolean;	begin		if (changed) then		begin			buttonClicked := SaveFirst;			if (buttonClicked = saveBut) then			begin				if (fileIsOpen) then				begin					if DoSaveHouse then					begin						doneFlag := TRUE;						dummyBool := DoClose;					end					else					begin						Exit(DoQuit);					end;				end				else	{else - file is NOT open}				begin					if DoSaveHouseAs then					begin						doneFlag := TRUE;						dummyBool := DoClose;					end					else						Exit(DoQuit);				end;			end			else if (buttonClicked = quitBut) then			begin				if (fileIsOpen) then					dummyBool := DoClose;				doneFlag := TRUE;			end			else if (buttonClicked = cancelBut) then				Exit(DoQuit);		end		{end - if changed}		else		{else - no changes}		begin			if (fileIsOpen) then				dummyBool := DoClose;			doneFlag := TRUE;		end;	end;{=================================}	procedure DoHelp;		var			aboutStuff: AboutRec;			tempR: Rect;			wasPort: GrafPtr;	begin		GetPort(wasPort);		SetPort(GrafPtr(mainWndo));		with aboutStuff do		begin			FontInfo[AboutMsg].Font := 0;			FontInfo[AboutMsg].Size := 0;			FontInfo[AboutMsg].Face := [];			FontInfo[AboutMsg].Color := RedColor;			FontInfo[AboutTEXT].Font := 1;			FontInfo[AboutTEXT].Size := 9;			FontInfo[AboutTEXT].Face := [];			FontInfo[AboutTEXT].Color := BlueColor;			TEXTCopy := TRUE;			KeyEquivs := TRUE;			CloseBox := FALSE;			Styled := TRUE;			CenterMode := AboutMainCenter;			MainIcon := 128;			ClickIcon := 129;			ClickMsg := 'by john calhoun  © 1991 Casady & Greene, Inc.';		end;		SetRect(tempR, 12, 30, 500, 332);		OffsetRect(tempR, rightOffset, downOffset);		BuildAbout(tempR, DBoxProc, 128, 'Editor Help', 'Room Editor 1.0 - General Help', aboutStuff);		SetPort(wasPort);	end;{=================================}	procedure DoCut;		var			cancelIt: Boolean;	begin		if (editRoom) then					{no object selected}		begin								{so, cut whole room}			if (not DeleteRoom) then			begin				scrapRoom := thisRoom;			{store room just cut}				FlushRoom(thisRoom);				{flush it}				cancelIt := FALSE;				{force user to create a room}				DoRoomBackInfo(cancelIt);			end			else			begin				roomScrapDirty := TRUE;				objectScrapDirty := FALSE;				SetItem(GetMenu(mEdit), iPaste, 'Paste Room');				EnableItem(GetMenu(mEdit), iPaste);				scrapRoom := thisRoom;				thisRoom := thisHouse.theRooms[roomAt];			end;			LoadABackground(thisRoom.backPictID);	{load the new room in}			oneActive := 0;					{insure no active object}			handleRect := nullRect;			DrawAllObjects;			DrawRoomNum;			changed := TRUE;		end		else		begin			objectScrapDirty := TRUE;			roomScrapDirty := FALSE;			SetItem(GetMenu(mEdit), iPaste, 'Paste Object');			EnableItem(GetMenu(mEdit), iPaste);			scrapObject := thisRoom.theObjects[oneActive];			thisRoom.theObjects[oneActive].objectIs := 0;			Deselect;	{Sort will set correct # of objects}			SortObjects;	{0-ing out the type will kill it in the sort routine}			DrawAllObjects;			changed := TRUE;		end;	end;{=================================}	procedure DoCopy;	begin		if (editRoom) then		begin			scrapRoom := thisRoom;			roomScrapDirty := TRUE;			objectScrapDirty := FALSE;			SetItem(GetMenu(mEdit), iPaste, 'Paste Room');			EnableItem(GetMenu(mEdit), iPaste);		end		else		begin			scrapObject := thisRoom.theObjects[oneActive];			objectScrapDirty := TRUE;			roomScrapDirty := FALSE;			SetItem(GetMenu(mEdit), iPaste, 'Paste Object');			EnableItem(GetMenu(mEdit), iPaste);		end;	end;{=================================}	procedure DoPaste;	begin		if (roomScrapDirty) then		begin			if (not InsertRoom) then				Exit(DoPaste);			LoadABackground(thisRoom.backPictID);	{draw the pasted room in}			oneActive := 0;					{insure no active object}			handleRect := nullRect;			DrawAllObjects;			DrawRoomNum;			changed := TRUE;		end		else		begin			if (InsertObject) then			begin				SortObjects;				DrawAllObjects;				changed := TRUE;			end			else				Exit(DoPaste);		end;	end;{=================================}	procedure DoClear;		var			cancelIt: Boolean;	begin		if (editRoom) then		begin			if (not DeleteRoom) then			begin				FlushRoom(thisRoom);				{flush it}				cancelIt := FALSE;				{force user to create a room}				DoRoomBackInfo(cancelIt);			end			else			begin				thisRoom := thisHouse.theRooms[roomAt];			end;			LoadABackground(thisRoom.backPictID);	{load the new room in}			oneActive := 0;					{insure no active object}			handleRect := nullRect;			DrawAllObjects;			DrawRoomNum;			changed := TRUE;		end		else		begin			thisRoom.theObjects[oneActive].objectIs := 0;			Deselect;			SortObjects;			DrawAllObjects;			changed := TRUE;		end;	end;{=================================}	procedure HandleMenu;	{Handle menu selections realtime}		var			DNA, holdActive, i: integer;			DAName: Str255;			SavePort: GrafPtr;			boolHolder, cancelIt: boolean;	begin		case theMenu of			mApple: 				case theItem of					iNothing: 						;					iAboutEdit: 						DoAbout;					otherwise					begin						GetPort(SavePort);						GetItem(GetMenu(mApple), theItem, DAName);						DNA := OpenDeskAcc(DAName);						SetPort(SavePort);					end;				end;			mFile: 				case theItem of                   {Handle all commands in this menu list}					iNew: 						DoNewHouse;					iOpen: 						DoOpenHouse;					iClose: 						DoMenuClose;					iSave: 						cancelIt := DoSaveHouse;					iSaveAs: 						cancelIt := DoSaveHouseAs;					iQuit: 						DoQuit;					otherwise				end;			mEdit: 				case theItem of	{Handle all commands in this menu list}					iCut: 						DoCut;					iCopy: 						DoCopy;					iPaste: 						DoPaste;					iClear: 						DoClear;					otherwise						;				end;			mSpecial: 				case theItem of	{Handle all commands in this menu list}					iTryGlider: 						FlyGlider;					iControls: 						;					iRestoreDeep: 					begin						restoreColor := not restoreColor;						if (restoreColor) then							SetItem(GetMenu(mSpecial), iRestoreDeep, 'Depth Restore is On')						else							SetItem(GetMenu(mSpecial), iRestoreDeep, 'Depth Restore is Off');					end;					iGoToRoom: 						DoGoToRoom;					iNextRoom: 						DoNextRoom;					iPrevRoom: 						DoPrevRoom;					iNewRoom: 						DoNewRoom;					otherwise						;				end;			mWindows: 				case theItem of	{Handle all commands in this menu list}					iTools: 						OpenTools;					iAutoHideTools: 					begin						autoHide := not autoHide;						if (autoHide) then							SetItem(GetMenu(mWindows), iAutoHideTools, 'Auto-Hide Tools is On')						else							SetItem(GetMenu(mWindows), iAutoHideTools, 'Auto-Hide Tools is Off');					end;					iHouse: 						DoHouseInfo;					iRoomBack: 					begin						cancelIt := TRUE;						DoRoomBackInfo(cancelIt);						LoadABackground(thisRoom.backPictID);						DrawAllObjects;					end;					iRoomCond: 					begin						cancelIt := TRUE;						DoRoomCondInfo(cancelIt);						DrawAllObjects;					end;					iObject: 						DoObjectInfo;					iHelp: 						DoHelp;					otherwise				end;			mControls: 				case theItem of					iHoldKey..iRelMouse: 					begin						for i := iHoldkey to iRelMouse do							CheckItem(GetMenu(mControls), i, FALSE);						CheckItem(GetMenu(mControls), theItem, TRUE);						controlMethod := theItem;					end;					iConfigure: 						DoCustomizeKeys;					otherwise				end;			kHMHelpMenuID: 				if (theItem = iGlidersHelp) then					DoHelp;			otherwise		end;		HiliteMenu(0);	end;{=================================}end.                                    {End of unit}