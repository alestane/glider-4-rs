unit HouseStuff;interface	uses		Palettes, Globals, Utilities;	function DeleteRoom: Boolean;	function InsertRoom: Boolean;	procedure DoHouseInfo;	procedure ErrorCheckHouse;implementation{=================================}	function DeleteRoom;		var			i: Integer;	begin		DeleteRoom := FALSE;								{assume error}		if (roomAt < thisHouse.numberORooms) then			{if not on last room}			for i := roomAt to thisHouse.numberORooms do				thisHouse.theRooms[i] := thisHouse.theRooms[i + 1];	{shift rooms left}		thisHouse.numberORooms := thisHouse.numberORooms - 1;	{subtract 1 from #}		if (roomAt > 1) then			roomAt := roomAt - 1							{preceding room is activated}		else		begin			roomAt := 1;			if (thisHouse.numberORooms <= 1) then				{if only one room}			begin				thisHouse.numberORooms := 1;					{we'll call up the dlg}				Exit(DeleteRoom);							{for creating a room}			end;		end;		DeleteRoom := TRUE;	end;{=================================}	function InsertRoom;		var			i: Integer;	begin		InsertRoom := FALSE;		if (thisHouse.numberORooms >= 40) then				{trying to add 41 rooms}		begin			GenericAlert(kErrTooManyRooms);			Exit(InsertRoom);		end;		thisHouse.theRooms[roomAt] := thisRoom;				{insert room to date}		if (roomAt < thisHouse.numberORooms) then			{shift only if in middle}			for i := thisHouse.numberORooms downto roomAt + 1 do				thisHouse.theRooms[i + 1] := thisHouse.theRooms[i];	{shift rooms right}		roomAt := roomAt + 1;							{kick roomAt over to right}		thisHouse.theRooms[roomAt] := scrapRoom;				{copy scrap into house}		thisRoom := thisHouse.theRooms[roomAt];				{get copy for active room}		thisHouse.numberORooms := thisHouse.numberORooms + 1;	{one more room}		InsertRoom := TRUE;	end;{=================================}	procedure DoFlushScores;		var			i: Integer;	begin		for i := 0 to 19 do		begin			thisHouse.hiScores[i] := 0;			thisHouse.hiLevel[i] := 0;			thisHouse.hiName[i] := 'no one...';			thisHouse.hiRoom[i] := 'no room...';		end;	end;{=================================}	procedure DoHouseInfo;		const			okayBut = 1;			nameStat = 2;			numOfStat = 3;			versStat = 4;			backStat = 5;			firstEdit = 6;			nextEdit = 7;			flushBut = 8;			lockBut = 17;			cancelBut = 18;		var			leaveDlg, willLockIt: Boolean;			theDlgPtr: DialogPtr;			wasPort: GrafPtr;			tempRect: Rect;			cntlType, index, itemHit, tempInt, rightOff, downOff: Integer;			dlgItem: Handle;			cntlHand, tempCntlHand: controlhandle;			tempStr, tempStr2: Str255;{-------------------------}		procedure Redraw;			var				width: Integer;		begin			SetPort(theDlgPtr);     		{Point to our dialog window}			GetDItem(theDlgPtr, okayBut, cntlType, dlgItem, tempRect);{Get the item handle}			PenSize(3, 3);  				{Change pen to draw thick default outline}			InsetRect(tempRect, -4, -4);     	{Draw outside the button by 1 pixel}			FrameRoundRect(tempRect, 16, 16); {Draw the outline}			PenNormal;			with theDlgPtr^.portRect do				width := right - left;			MoveTo(4, 38);			Line(width - 8, 0);			MoveTo(4, 40);			Line(width - 8, 0);			GetKeys(theKeys);			if (theKeys[$37]) then			begin				MoveTo(5, 37);				NumToString(thisHouse.timeStamp, tempStr);				DrawString(tempStr);			end;		end;{-------------------------}	begin		GetPort(wasPort);		theDlgPtr := GetNewDialog(houseInfoID, nil, Pointer(-1));		with theDlgPtr^.portBits do		begin			rightOff := rightOffset - bounds.left;			downOff := downOffset - bounds.top;		end;		MoveWindow(theDlgPtr, rightOff, downOff, FALSE);		ShowWindow(theDlgPtr);		SelectWindow(theDlgPtr);		SetPort(theDlgPtr);		GetDItem(theDlgPtr, nameStat, cntlType, dlgItem, tempRect);		SetIText(dlgItem, housesName);		with thisHouse do		begin			NumToString(numberORooms, tempStr);		{pop in number of rooms}			GetDItem(theDlgPtr, numOfStat, cntlType, dlgItem, tempRect);			SetIText(dlgItem, tempStr);			tempInt := version div 256;				{compute version number}			NumToString(tempInt, tempStr);			tempInt := version mod 256;			NumToString(tempInt, tempStr2);			tempStr := CONCAT(tempStr, '.', tempStr2);	{and pop it in}			GetDItem(theDlgPtr, versStat, cntlType, dlgItem, tempRect);			SetIText(dlgItem, tempStr);			GetDItem(theDlgPtr, backStat, cntlType, dlgItem, tempRect);			SetIText(dlgItem, pictFile);				{pop in background file}			GetDItem(theDlgPtr, firstEdit, cntlType, dlgItem, tempRect);			SetIText(dlgItem, firstFile);			{pop in first house file}			GetDItem(theDlgPtr, nextEdit, cntlType, dlgItem, tempRect);			SetIText(dlgItem, nextFile);				{pop in next house file}		end;		willLockIt := lockIt;		Redraw;		leaveDlg := FALSE;		SelIText(theDlgPtr, nextEdit, 0, 32);		repeat			ModalDialog(nil, itemHit);			GetDItem(theDlgPtr, itemHit, cntlType, dlgItem, tempRect);			if (itemHit = okayBut) then			begin				leaveDlg := TRUE;				GetDItem(theDlgPtr, firstEdit, cntlType, dlgItem, tempRect);				GetIText(dlgItem, tempStr);	{Get text entered for first file}				thisHouse.firstFile := COPY(tempStr, 1, 32);				GetDItem(theDlgPtr, nextEdit, cntlType, dlgItem, tempRect);				GetIText(dlgItem, tempStr);	{Get text entered for next file}				thisHouse.nextFile := COPY(tempStr, 1, 32);				lockIt := willLockIt;				changed := TRUE;			end;			if (itemHit = cancelBut) then			begin				leaveDlg := TRUE;			end;			if (itemHit = lockBut) then			begin				if (Alert(lockAlertID, nil) = 1) then					willLockIt := TRUE;			end;			if (itemHit = flushBut) then				DoFlushScores;		until leaveDlg;		DisposDialog(theDlgPtr);		if (toolWndo <> nil) then			SetPort(toolWndo)		else			SetPort(wasPort);	end;{=================================}	procedure ErrorCheckHouse;		const			roomUnnamed = 1;			tooManyObs = 2;			badPictID = 3;			badAnimKind = 4;			badAnimNum = 5;			badAnimDelay = 6;			badRoomCond = 7;		type			problem = record					howMany: Integer;					whichOnes: array[1..40] of Boolean;				end;			problemTally = array[roomUnnamed..badRoomCond] of problem;		var			i, i2, obs: Integer;			progR: Rect;			theProblems: problemTally;	begin		SetPort(GrafPtr(mainWndo));		PenNormal;		TextFont(0);		TextSize(12);		PenSize(2, 2);		SetRect(progR, 156, 100, 356, 130);{check house record}		EraseRect(progR);		FrameRect(progR);		MoveTo(progR.left + 20, progR.bottom - 10);		DrawString('Checking House…');		with thisHouse do		begin			SpinBall;			if (version > $01FF) then			begin				GenericAlert(kErrWrongHouseVers);				EraseRect(progR);				FrameRect(progR);				MoveTo(progR.left + 20, progR.bottom - 10);				DrawString('Checking House…');			end;			SpinBall;			if ((numberORooms < 1) or (numberORooms > 40)) then			begin				GenericAlert(18);				EraseRect(progR);				FrameRect(progR);				MoveTo(progR.left + 20, progR.bottom - 10);				DrawString('Checking House…');			end;{check room records}			EraseRect(progR);			FrameRect(progR);			MoveTo(progR.left + 20, progR.bottom - 10);			DrawString('Checking Rooms…');			for i := roomUnnamed to badRoomCond do				with theProblems[i] do				begin					howMany := 0;					for i2 := 1 to 40 do						whichOnes[i2] := FALSE;				end;			for i := 1 to numberORooms do				with theRooms[i] do				begin					SpinBall;					if (roomName = '') then						with theProblems[roomUnnamed] do						begin							howMany := howMany + 1;							whichOnes[i] := TRUE;						end;					SpinBall;					if ((numberOObjects < 0) or (numberOObjects > 16)) then						with theProblems[tooManyObs] do						begin							howMany := howMany + 1;							whichOnes[i] := TRUE;						end;					SpinBall;					if ((backPictID < 200) or (backPictID > 209)) then						with theProblems[badPictID] do						begin							howMany := howMany + 1;							whichOnes[i] := TRUE;						end;					SpinBall;					if ((animateKind < 0) or (animateKind > 3)) then						with theProblems[badAnimKind] do						begin							howMany := howMany + 1;							whichOnes[i] := TRUE;						end;					SpinBall;					if ((animateNumber < 0) or (animateNumber > 16)) then						with theProblems[badAnimNum] do						begin							howMany := howMany + 1;							whichOnes[i] := TRUE;						end;					SpinBall;					if (animateDelay < 0) then						with theProblems[badAnimDelay] do						begin							howMany := howMany + 1;							whichOnes[i] := TRUE;						end;					SpinBall;					if ((conditionCode < 0) or (conditionCode > 2)) then						with theProblems[badRoomCond] do						begin							howMany := howMany + 1;							whichOnes[i] := TRUE;						end;				end;			InitCursor;			for i := roomUnnamed to badRoomCond do				if (theProblems[i].howMany <> 0) then				begin					GenericAlert(19);					Leave;				end;		end;		if (inColor) then			CopyBits(BitMapPtr(loadCPtr^.portPixMap^)^, GrafPtr(mainWndo)^.portBits, progR, progR, srcCopy, GrafPtr(mainWndo)^.visRgn)		else			CopyBits(offLoadMap, mainWndo^.portBits, progR, progR, srcCopy, mainWndo^.visRgn);		if (toolWndo <> nil) then			SetPort(GrafPtr(toolWndo));	end;{=================================}end.