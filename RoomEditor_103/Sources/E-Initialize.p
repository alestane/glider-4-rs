unit Initialize;interface	uses		Balloons, Palettes, Globals, Utilities, RoomStuff;	procedure InitVariables;{=================================}implementation{=================================}	procedure InitVariables;		var			index, theDepth: Integer;			sizeOfOff, offRowBytes: LongInt;			tempByte: SignedByte;			rawPointer: Ptr;			thePict: PicHandle;			tempRect: Rect;			ignore: Boolean;{---------------------}		procedure CheckOurEnvirons;			const				WNETrapNum = $60;				unimplTrapNum = $9F;				Color = 1;				Monochrome = 0;				GDTypeFlag = 1;			var				sheSaid: Integer;				err: OSErr;				thisWorld: SysEnvRec;				theDevice: GDHandle;{-----------}			function DepthAlert: Integer;				var					dummyInt: Integer;					alertHandle: AlertTHndl;					alertRect: Rect;			begin				UseResFile(editorResNum);				InitCursor;				alertHandle := AlertTHndl(Get1Resource('ALRT', depthAlertID));				if (alertHandle <> nil) then				begin					HNoPurge(Handle(alertHandle));					alertRect := alertHandle^^.boundsRect;					OffsetRect(alertRect, -alertRect.left, -alertRect.top);					dummyInt := (screenBits.bounds.right - alertRect.right) div 2;					OffsetRect(alertRect, dummyInt, 0);					dummyInt := (screenBits.bounds.bottom - alertRect.bottom) div 3;					OffsetRect(alertRect, 0, dummyInt);					alertHandle^^.boundsRect := alertRect;					HPurge(Handle(alertHandle));				end;				dummyInt := Alert(depthAlertID, nil);				DepthAlert := dummyInt;			end;{-----------}			function SetDepth (gd: GDHandle; newDepth, whichFlags, newFlags: Integer): Integer;			inline				$203C, $000A, $0013, $AAA2;{-----------}		begin			rightOffset := (ScreenBits.bounds.right - 512) div 2;			downOffset := (ScreenBits.bounds.bottom - 342) div 2;			err := SysEnvirons(1, thisWorld);	{Check on the set up of the Mac game is on	}			with thisWorld do			begin				if (machineType < 1) then		{If less than a Mac 512KE (=1) then quit now!}				begin					GenericAlert(kErrMacPlusNeeded);					ExitToShell;				end;				if (systemVersion < $0602) then				begin					inhibitSound := TRUE;					GenericAlert(3);				end				else					inhibitSound := FALSE;				cantColor := not hasColorQD;				inColor := hasColorQD;				cantSwitch := (systemVersion < $0605);				hasSys7 := (systemVersion >= $0700);				if (inColor) then				begin					theDevice := GetMainDevice;					HLock(Handle(theDevice));					with theDevice^^.gdPMap^^ do					begin						wasDepth := pixelSize;						if ((pixelSize <> 4) and (pixelSize <> 1)) then							if (cantSwitch) then							begin								GenericAlert(kErr2Or16Colors);								ExitToShell;							end							else							begin								sheSaid := DepthAlert;								case sheSaid of									1: 										err := SetDepth(theDevice, 4, GDTypeFlag, Color);									2: 									begin										err := SetDepth(theDevice, 1, GDTypeFlag, Color);										inColor := FALSE;									end;									otherwise										ExitToShell;								end;							end;						if (pixelSize = 1) then							inColor := FALSE;					end;					HUnlock(Handle(theDevice));				end;				herKeyboard := keyBoardType;				case keyBoardType of		{determine keycodes}					envMacPlusKbd: 					begin						leftArrow := $46;						rightArrow := $42;						deleteKey := $33;					end;					envAExtendKbd, envStandADBKbd: 					begin						leftArrow := $7B;						rightArrow := $7C;						deleteKey := $33;					end;					otherwise					begin						leftArrow := $2B;						rightArrow := $2F;						deleteKey := $0;					end;				end;	{case}			end;			{end - with}			hasWNE := (NGetTrapAddress(WNETrapNum, ToolTrap) <> NGetTrapAddress(unimplTrapNum, toolTrap));		end;{---------------------}		procedure LoadCursors;			var				count: Integer;				tempByte: SignedByte;		begin			useColorCursor := inColor;			UseResFile(editorResNum);			ballList := acurHand(GetResource('acur', acurID));			if (ballList = nil) then			begin				GenericAlert(kErrLoadingRes);				Exit(LoadCursors);			end;			tempByte := HGetState(Handle(ballList));			HLock(Handle(ballList));			with ballList^^ do			begin				for count := 1 to kCursCount do				begin					if (useColorCursor) then					begin						ballC[count] := GetCCursor(HiWord(LongInt(ball[count])));						if (ballC[count] = nil) then							useColorCursor := FALSE;					end;					ball[count] := GetCursor(HiWord(LongInt(ball[count])));					if (ball[count] = nil) then					begin						GenericAlert(kErrLoadingRes);						whichBall := -1;						Exit(LoadCursors);					end;				end;				whichBall := 0;			end;			HSetState(Handle(ballList), tempByte);		end;{---------------------}		procedure SetUpColors;		begin			SpinBall;			rgbBlack.red := 0;			rgbBlack.green := 0;			rgbBlack.blue := 0;			rgbWhite.red := -1;			rgbWhite.green := -1;			rgbWhite.blue := -1;			rgbYellow.red := -1;			rgbYellow.green := -1;			rgbYellow.blue := 0;			rgbViolet.red := -1;			rgbViolet.green := 0;			rgbViolet.blue := -1;			rgbRed.red := -1;			rgbRed.green := 0;			rgbRed.blue := 0;			rgbLtBlue.red := 0;			rgbLtBlue.green := -1;			rgbLtBlue.blue := -1;			rgbBrown.red := 22016;			rgbBrown.green := 11421;			rgbBrown.blue := 1316;			rgbLtBrown.red := -28457;			rgbLtBrown.green := 29024;			rgbLtBrown.blue := 14900;			rgbDkGray.red := 16384;			rgbDkGray.green := 16384;			rgbDkGray.blue := 16384;		end;{---------------------}		procedure SetUpMainWndo;		begin			SpinBall;			SetRect(screenArea, 0, 0, 512, 322);			SetRect(wholeArea, 0, 0, 512, 342);			SetRect(nullRect, -500, -500, -499, -499);			SetRect(fullArea, -rightOffset, -downOffset, 512 + rightOffset, 342 + downOffset);			wholeRgn := NewRgn;			RectRgn(wholeRgn, wholeArea);			SpinBall;{Init main window}			mainWndo := nil;			if (inColor) then				mainWndo := GetNewCWindow(mainWndoID, nil, WindowPtr(-1))			else				mainWndo := GetNewWindow(mainWndoID, nil, WindowPtr(-1));			if (mainWndo = nil) then				GenericAlert(kErrLoadingRes);			SetPort(GrafPtr(mainWndo));			MoveWindow(GrafPtr(mainWndo), rightOffset, downOffset, FALSE);			ShowWindow(GrafPtr(mainWndo));			SetWRefCon(mainWndo, 0);			ClipRect(wholeArea);			if (inColor) then			begin				mainPalette := GetNewPalette(mainWndoID);				SetPalette(mainWndo, mainPalette, TRUE);			end;		end;{---------------------}		procedure SetUpMenus;			var				tempMenu: MenuHandle;				theErr: OSErr;		begin			SpinBall;			ClearMenuBar;			tempMenu := GetMenu(mApple);			if (tempMenu <> nil) then			begin				AddResMenu(tempMenu, 'DRVR');				InsertMenu(tempMenu, 0);			end			else			begin				GenericAlert(kErrUnknownAtInit);				ExitToShell;			end;			SpinBall;			tempMenu := GetMenu(mFile);			if (tempMenu <> nil) then				InsertMenu(tempMenu, 0)			else			begin				GenericAlert(kErrUnknownAtInit);				ExitToShell;			end;			SpinBall;			tempMenu := GetMenu(mEdit);			if (tempMenu <> nil) then				InsertMenu(tempMenu, 0)			else			begin				GenericAlert(kErrUnknownAtInit);				ExitToShell;			end;			SpinBall;			tempMenu := GetMenu(mSpecial);			if (tempMenu <> nil) then				InsertMenu(tempMenu, 0)			else			begin				GenericAlert(kErrUnknownAtInit);				ExitToShell;			end;			SpinBall;			tempMenu := GetMenu(mControls);			if (tempMenu <> nil) then				InsertMenu(tempMenu, -1)			else			begin				GenericAlert(kErrUnknownAtInit);				ExitToShell;			end;			SpinBall;			tempMenu := GetMenu(mWindows);			if (tempMenu <> nil) then				InsertMenu(tempMenu, 0)			else			begin				GenericAlert(kErrUnknownAtInit);				ExitToShell;			end;			if (hasSys7) then		{add a Help menu item}			begin				theErr := HMGetHelpMenuHandle(tempMenu);				if (theErr = noErr) then					if (tempMenu <> nil) then					begin						AppendMenu(tempMenu, 'Room Editor Help');						iGlidersHelp := CountMItems(tempMenu);					end					else					begin						tempMenu := GetMenu(mWindows);						AppendMenu(tempMenu, '(-');						AppendMenu(tempMenu, 'Help');					end				else				begin					tempMenu := GetMenu(mWindows);					AppendMenu(tempMenu, '(-');					AppendMenu(tempMenu, 'Help');				end;			end			else			begin				AppendMenu(tempMenu, '(-');				AppendMenu(tempMenu, 'Help');			end;			SpinBall;			DrawMenuBar;		end;{---------------------}		function NewBitMap (var theBitMap: BitMap; theRect: Rect): Ptr;		begin			with theBitMap, theRect do			begin				rowBytes := ((right - left + 15) div 16) * 2;				baseAddr := NewPtr(rowBytes * (bottom - top));				bounds := theRect;				if (MemError <> noErr) then				begin					GenericAlert(kErrNotEnoughMem);					NewBitMap := nil;					ExitToShell;				end				else					NewBitMap := baseAddr;			end;		end;{---------------------}		procedure SetUpBitMaps;		begin			SpinBall;{Init b&w Bitmaps}{Init offscreen virgin map}			offVirginPort := GrafPtr(NewPtr(SizeOf(GrafPort)));			OpenPort(offVirginPort);			offVirginBits := NewBitMap(offVirginMap, wholeArea);			SetPortBits(offVirginMap);			ClipRect(wholeArea);			EraseRect(offVirginMap.bounds);			SpinBall;{Init offscreen load map}			offLoadPort := GrafPtr(NewPtr(SizeOf(GrafPort)));			OpenPort(offLoadPort);			offLoadBits := NewBitMap(offLoadMap, wholeArea);			SetPortBits(offLoadMap);			ClipRect(wholeArea);			EraseRect(offLoadMap.bounds);			SpinBall;{Init offscreen object map}			offPlayerPort := GrafPtr(NewPtr(SizeOf(GrafPort)));			OpenPort(offPlayerPort);			offPlayerBits := NewBitMap(offPlayerMap, wholeArea);			SetPortBits(offPlayerMap);			ClipRect(wholeArea);			EraseRect(offPlayerMap.bounds);		end;{---------------------}		procedure SetUpPixMaps;		begin			SetPort(GrafPtr(mainWndo));			RGBForeColor(rgbBlack);			RGBBackColor(rgbWhite);			SpinBall;			virginCPtr := @virginCPort;			OpenCPort(virginCPtr);			theDepth := 4;			offRowBytes := ((((theDepth * (wholeArea.right - wholeArea.left)) + 15)) div 16) * 2;			sizeOfOff := LONGINT(wholeArea.bottom - wholeArea.top) * offRowBytes;			virginCBits := NewPtr(sizeOfOff);			if (virginCPtr = nil) then			begin				GenericAlert(kErrNotEnoughMem);				ExitToShell;			end;			with virginCPtr^.portPixMap^^ do			begin				baseAddr := virginCBits;				rowBytes := offRowBytes + $8000;				bounds := wholeArea;			end;			RGBForeColor(rgbBlack);			RGBBackColor(rgbWhite);			EraseRect(thePort^.portRect);			ClipRect(wholeArea);			SpinBall;			loadCPtr := @loadCPort;			OpenCPort(loadCPtr);			loadCBits := NewPtr(sizeOfOff);			if (loadCBits = nil) then			begin				GenericAlert(kErrNotEnoughMem);				ExitToShell;			end;			with loadCPtr^.portPixMap^^ do			begin				baseAddr := loadCBits;				rowBytes := offRowBytes + $8000;				bounds := wholeArea;			end;			RGBForeColor(rgbBlack);			RGBBackColor(rgbWhite);			EraseRect(thePort^.portRect);			ClipRect(wholeArea);			SpinBall;			objectCPtr := @objectCPort;			OpenCPort(objectCPtr);			objectCBits := NewPtr(sizeOfOff);			if (objectCBits = nil) then			begin				GenericAlert(kErrNotEnoughMem);				ExitToShell;			end;			with objectCPtr^.portPixMap^^ do			begin				baseAddr := objectCBits;				rowBytes := offRowBytes + $8000;				bounds := wholeArea;			end;			RGBForeColor(rgbBlack);			RGBBackColor(rgbWhite);			EraseRect(thePort^.portRect);			ClipRect(wholeArea);		end;{---------------------}		procedure SetUpOffMask;		begin			SpinBall;{Init offscreen mask map}			offMaskPort := GrafPtr(NewPtr(SizeOf(GrafPort)));			OpenPort(offMaskPort);			offMaskBits := NewBitMap(offMaskMap, wholeArea);			SetPortBits(offMaskMap);			ClipRect(wholeArea);			EraseRect(offMaskMap.bounds);		end;{---------------------}		function DoOpenResFile: Boolean;			var				dlgOrigin: Point;				theTypeList: SFTypeList;				theReply: SFReply;		begin			SpinBall;			DoOpenResFile := FALSE;			SetPt(dlgOrigin, dlgLeft + rightOffset, dlgTop + downOffset);			theTypeList[0] := 'GLbk';			SFGetFile(dlgOrigin, '', nil, 1, theTypeList, nil, theReply);			with theReply do			begin				if (good) then				begin					resourceName := fName;					DoOpenResFile := TRUE;				end;			end;		end;{-----------------}		procedure GetPrefs;			type				prefType = record						resName: string[32];						controlIs: Integer;						leftIs, rightIs, energyIs, bandIs: Integer;						buttonIs, restoreIs: Boolean;						leftNameIs, rightNameIs, energyNameIs, bandNameIs: string[12];						isKeyBoard: Integer;					end;				prefPtr = ^prefType;				prefHand = ^prefPtr;				pictDeepPt = ^Integer;				pictDeepHn = ^pictDeepPt;			var				theirPrefs: prefHand;				pictDeep: pictDeepHn;				refNumber, tempVol: Integer;				satisfactory: Boolean;{-----------------}			procedure DefaultControls;			begin				leftKey := defaultLeftKey;				rightKey := defaultRightKey;				energyKey := defaultEnergyKey;				bandKey := defaultBandKey;				buttonFires := FALSE;				leftName := defaultLeftName;				rightName := defaultRightName;				energyName := defaultEnergyName;				bandName := defaultBandName;			end;{-----------------}			procedure Default;			begin				if (inColor) then					resourceName := 'Art 16'				else					resourceName := 'Art 2';				controlMethod := absMouse;				restoreColor := TRUE;				DefaultControls;			end;{-----------------}		begin			SpinBall;			UseResFile(editorResNum);			theirPrefs := prefHand(NewHandle(SIZEOF(prefType)));			if (theirPrefs = nil) then			begin				Default;				Exit(GetPrefs);			end;			Handle(theirPrefs) := GetResource('Gprf', 128);			if ((ResError = noErr) and (theirPrefs <> nil)) then			begin				HLock(Handle(theirPrefs));				with theirPrefs^^ do				begin					resourceName := resName;					controlMethod := controlIs;					leftKey := leftIs;					rightKey := rightIs;					energyKey := energyIs;					bandKey := bandIs;					buttonFires := buttonIs;					restoreColor := restoreIs;					leftName := leftNameIs;					rightName := rightNameIs;					energyName := energyNameIs;					bandName := bandNameIs;					if (isKeyBoard <> herKeyBoard) then						DefaultControls;				end;				HUnlock(Handle(theirPrefs));				ReleaseResource(Handle(theirPrefs));			end			else			begin				Default;			end;			SpinBall;			if ((controlMethod < holdKey) or (controlMethod > relMouse)) then				controlMethod := absMouse;			CheckItem(GetMenu(mControls), controlMethod, TRUE);			if (restoreColor) then				SetItem(GetMenu(mSpecial), iRestoreDeep, 'Depth Restore is On')			else				SetItem(GetMenu(mSpecial), iRestoreDeep, 'Depth Restore is Off');			if ((cantColor) or (cantSwitch)) then				DisableItem(GetMenu(mSpecial), iRestoreDeep);			refNumber := OpenResFile(resourceName);	{test to see if res legit}			if (refNumber = -1) then			begin				if (ResError = resFNotFound) then		{Hmmm.  Maybe color depth has changed}				begin					if (inColor) then						resourceName := 'Color Art'			{Try the default color name}					else						resourceName := 'B&W Art';			{Or default B&W file name}					refNumber := OpenResFile(resourceName);	{test to see if res legit yet}					if (refNumber = -1) then					begin						UseResFile(editorResNum);			{back to Editor res file}						GenericAlert(kErrGraphicsNotFound);	{bitch about all this}						if (not DoOpenResFile) then						begin							GenericAlert(kErrExitSansGraphics);							ExitToShell;						end;						refNumber := OpenResFile(resourceName);					end;				end				else				begin					UseResFile(editorResNum);			{back to Editor res file}					GenericAlert(kErrGraphicsNotFound);	{bitch about all this}					if (not DoOpenResFile) then					begin						GenericAlert(kErrExitSansGraphics);						ExitToShell;					end;					refNumber := OpenResFile(resourceName);				end;			end;			satisfactory := FALSE;			repeat				UseResFile(refNumber);				pictDeep := pictDeepHn(NewHandle(SIZEOF(Integer)));				if (pictDeep = nil) then				begin					GenericAlert(kErrNotEnoughMem);					ExitToShell;				end;				Handle(pictDeep) := GetResource('deep', 128);				if ((ResError = noErr) and (pictDeep <> nil)) then				begin					HLock(Handle(pictDeep));					if (inColor) then					begin						if (pictDeep^^ <> $0004) then						begin							if (pictDeep <> nil) then							begin								HUnlock(Handle(pictDeep));								ReleaseResource(Handle(pictDeep));								pictDeep := nil;							end;							CloseResFile(refNumber);							if (resourceName <> 'Color Art') then							begin								resourceName := 'Color Art';								refNumber := OpenResFile(resourceName);							end							else							begin								GenericAlert(21);								if (not DoOpenResFile) then								begin									GenericAlert(kErrExitSansGraphics);									ExitToShell;								end;								refNumber := OpenResFile(resourceName);							end;						end						else							satisfactory := TRUE;					end					else		{were in b&w mode}					begin						if (pictDeep^^ <> $0001) then						begin							if (pictDeep <> nil) then							begin								HUnlock(Handle(pictDeep));								ReleaseResource(Handle(pictDeep));								pictDeep := nil;							end;							CloseResFile(refNumber);							if (resourceName <> 'B&W Art') then							begin								resourceName := 'B&W Art';								refNumber := OpenResFile(resourceName);							end							else							begin								GenericAlert(22);								if (not DoOpenResFile) then								begin									GenericAlert(20);									ExitToShell;								end;								refNumber := OpenResFile(resourceName);							end;						end						else							satisfactory := TRUE;					end;				end				else				begin					GenericAlert(kErrNotEnoughMem);					ExitToShell;				end;				if (pictDeep <> nil) then				begin					HUnlock(Handle(pictDeep));					ReleaseResource(Handle(pictDeep));					pictDeep := nil;				end;			until satisfactory;			CloseResFile(refNumber);			UseResFile(editorResNum);		end;{---------------------}		procedure LoadPICTs;			var				refNumber: Integer;				wasPort: GrafPtr;		begin			SpinBall;			refNumber := OpenResFile(resourceName);			if (refNumber = -1) then			begin				UseResFile(editorResNum);				GenericAlert(kErrGraphicsNotFound);				if (not DoOpenResFile) then					ExitToShell;				refNumber := OpenResFile(resourceName);				if (refNumber = -1) then				begin					GenericAlert(kErrGraphicsNotFound);					ExitToShell;				end;			end;			UseResFile(refNumber);			SpinBall;			GetPort(wasPort);			if (inColor) then					{load the objects up}				SetPort(GrafPtr(objectCPtr))			else				SetPort(offPlayerPort);			thePict := GetPicture(objectPictID);			if (thePict^ <> nil) then			begin				tempByte := HGetState(Handle(thePict));				MoveHHi(Handle(thePict));				HLock(Handle(thePict));				DrawPicture(thePict, wholeArea);				HSetState(Handle(thePict), tempByte);			end			else			begin				GenericAlert(kErrNotEnoughMem);				ExitToShell;			end;			ReleaseResource(Handle(thePict));			SpinBall;			SetPort(offMaskPort);			thePict := GetPicture(maskPictID);	{load the mask up}			if (thePict^ <> nil) then			begin				tempByte := HGetState(Handle(thePict));				MoveHHi(Handle(thePict));				HLock(Handle(thePict));				DrawPicture(thePict, wholeArea);				HSetState(Handle(thePict), tempByte);			end			else			begin				GenericAlert(kErrNotEnoughMem);				ExitToShell;			end;			ReleaseResource(Handle(thePict));			SpinBall;			SetPort(wasPort);			CloseResFile(refNumber);			UseResFile(editorResNum);		end;{---------------------}	begin		editorResNum := CurResFile;		SetApplLimit(Ptr(LongInt(GetApplLimit) - StackSize));		MaxApplZone;		for index := 1 to 10 do			MoreMasters;		InitGraf(@thePort);		InitFonts;		InitWindows;		InitMenus;		TEInit;		InitDialogs(nil);		InitCursor;		for index := 1 to 3 do			ignore := EventAvail(EveryEvent, theEvent);		inBackground := FALSE;		SetCursor(GetCursor(WatchCursor)^^);		CheckOurEnvirons;		LoadCursors;		SpinBall;		if (inColor) then			SetUpColors;		SpinBall;		SetUpMenus;		SpinBall;		SetUpMainWndo;		SpinBall;		if (inColor) then			SetUpPixMaps		else			SetUpBitMaps;		SpinBall;		SetUpOffMask;		SpinBall;		GetPrefs;		SpinBall;		LoadPICTs;		SpinBall;		doneFlag := FALSE;		soundOn := not inhibitSound;		playing := FALSE;		pausing := FALSE;		roomScrapDirty := FALSE;		objectScrapDirty := FALSE;		fileIsOpen := FALSE;		autoHide := FALSE;		lightsOut := FALSE;		bandBorne := TRUE;		lockIt := FALSE;		binaryFlip := 1;		GetDateTime(RandSeed);		FlushRoom(thisRoom);		setOTools := 0;		toolWndo := nil;		housesName := 'untitled';		marqueeTime := FALSE;		marqueeIndex := 0;		for index := 0 to 4 do		begin			SpinBall;			GetIndPattern(marqueePat[index], 128, index + 1);		end;		for index := 0 to 7 do			SetRect(tileRects[index], index * 64, 0, (index + 1) * 64, 342);		SetRect(iconRect[0], 5, 55, 37, 87);		SetRect(iconRect[1], 41, 55, 73, 87);		SetRect(iconRect[2], 5, 90, 37, 122);		SetRect(iconRect[3], 41, 90, 73, 122);		SetRect(iconRect[4], 5, 125, 37, 157);		SetRect(iconRect[5], 41, 125, 73, 157);		SpinBall;		SetRect(selectRect[0], 8, 6, 24, 22);		SetRect(selectRect[1], 31, 6, 47, 22);		SetRect(selectRect[2], 54, 6, 70, 22);		SetRect(selectRect[3], 8, 28, 24, 44);		SetRect(selectRect[4], 31, 28, 47, 44);		SetRect(selectRect[5], 54, 28, 70, 44);		SetRect(shadoRct[0], 256, 0, 304, 11);		SetRect(shadoRct[1], 256, 12, 304, 23);		SpinBall;		SetRect(glideRct[0], 0, 0, 48, 20);		{right forward}		SetRect(glideRct[1], 0, 21, 48, 41);	{right tipped}		SetRect(glideRct[2], 0, 42, 48, 62);	{left forward}		SetRect(glideRct[3], 0, 63, 48, 83);	{left tipped}		SetRect(glideRct[4], 208, 0, 256, 20);	{turn endpoint}		SetRect(glideRct[5], 208, 21, 256, 41);	{  "  }		SetRect(glideRct[6], 208, 42, 256, 62);	{  "  }		SetRect(glideRct[7], 208, 63, 256, 83);	{  "  }		SetRect(glideRct[8], 208, 84, 256, 104);	{  "  }		SetRect(glideRct[9], 208, 105, 256, 125);{turn endpoint}		SetRect(glideRct[10], 414, 53, 462, 73);	{glider fading masks right}		SetRect(glideRct[11], 414, 74, 462, 94);		SetRect(glideRct[12], 414, 95, 462, 115);		SetRect(glideRct[13], 414, 116, 462, 136);		SetRect(glideRct[14], 414, 137, 462, 157);		SetRect(glideRct[15], 414, 158, 462, 178);		SetRect(glideRct[16], 414, 179, 462, 199);		SetRect(glideRct[17], 463, 53, 511, 73);	{glider fading masks left}		SetRect(glideRct[18], 463, 74, 511, 94);		SetRect(glideRct[19], 463, 95, 511, 115);		SetRect(glideRct[20], 463, 116, 511, 136);		SetRect(glideRct[21], 463, 137, 511, 157);		SetRect(glideRct[22], 463, 158, 511, 178);		SetRect(glideRct[23], 463, 179, 511, 199);		SetRect(glideRct[24], 265, 24, 313, 60);	{burning}		SetRect(glideRct[25], 265, 61, 313, 97);		SetRect(glideRct[26], 265, 98, 313, 134);		SetRect(glideRct[27], 265, 135, 313, 171);		SpinBall;		nextPhase[1, 0] := 10;		nextPhase[1, 1] := 11;		nextPhase[1, 2] := 10;		nextPhase[1, 3] := 11;		nextPhase[1, 4] := 12;		nextPhase[1, 5] := 11;		nextPhase[1, 6] := 12;		nextPhase[1, 7] := 13;		nextPhase[1, 8] := 12;		nextPhase[1, 9] := 13;		nextPhase[1, 10] := 14;		nextPhase[1, 11] := 13;		nextPhase[1, 12] := 14;		nextPhase[1, 13] := 15;		nextPhase[1, 14] := 14;		nextPhase[1, 15] := 15;		nextPhase[1, 16] := 16;		nextPhase[2, 0] := 16;		nextPhase[2, 1] := 15;		nextPhase[2, 2] := 16;		nextPhase[2, 3] := 15;		nextPhase[2, 4] := 14;		nextPhase[2, 5] := 15;		nextPhase[2, 6] := 14;		nextPhase[2, 7] := 13;		nextPhase[2, 8] := 14;		nextPhase[2, 9] := 13;		nextPhase[2, 10] := 12;		nextPhase[2, 11] := 13;		nextPhase[2, 12] := 12;		nextPhase[2, 13] := 11;		nextPhase[2, 14] := 12;		nextPhase[2, 15] := 11;		nextPhase[2, 16] := 10;		nextPhase[3, 0] := 4;		nextPhase[3, 1] := 4;		nextPhase[3, 2] := 5;		nextPhase[3, 3] := 5;		nextPhase[3, 4] := 6;		nextPhase[3, 5] := 6;		nextPhase[3, 6] := 7;		nextPhase[3, 7] := 7;		nextPhase[3, 8] := 8;		nextPhase[3, 9] := 8;		nextPhase[3, 10] := 9;		nextPhase[3, 11] := 9;		nextPhase[4, 0] := 9;		nextPhase[4, 1] := 9;		nextPhase[4, 2] := 8;		nextPhase[4, 3] := 8;		nextPhase[4, 4] := 7;		nextPhase[4, 5] := 7;		nextPhase[4, 6] := 6;		nextPhase[4, 7] := 6;		nextPhase[4, 8] := 5;		nextPhase[4, 9] := 5;		nextPhase[4, 10] := 4;		nextPhase[4, 11] := 4;		SpinBall;		SetRect(srcRect[celVnt], 0, 84, 48, 96);		SetRect(srcRect[celDct], 0, 97, 48, 110);		SetRect(srcRect[flrVnt], 0, 111, 48, 124);		SetRect(srcRect[paper], 0, 125, 48, 146);		SetRect(srcRect[toastr], 0, 147, 38, 174);		SetRect(srcRect[60], 304, 84, 336, 115);		{toast 1}		SetRect(srcRect[61], 304, 116, 336, 147);	{toast 2}		SetRect(srcRect[62], 304, 148, 336, 179);	{toast 3}		SetRect(srcRect[63], 304, 180, 336, 211);	{toast 4}		SetRect(srcRect[64], 304, 212, 336, 243);	{toast 5}		SetRect(srcRect[65], 304, 244, 336, 275);	{toast 6}		SetRect(srcRect[teaKtl], 0, 175, 41, 205);		SetRect(srcRect[lftFan], 0, 206, 35, 261);		SetRect(srcRect[ritFan], 0, 262, 35, 316);		SetRect(srcRect[table], 48, 23, 112, 45);		SetRect(srcRect[shredr], 48, 46, 112, 70);		SetRect(srcRect[books], 48, 71, 112, 126);		SetRect(srcRect[clock], 112, 0, 144, 29);		SetRect(srcRect[candle], 112, 30, 144, 51);		SetRect(srcRect[rbrBnd], 112, 52, 144, 75);		SetRect(srcRect[ball], 112, 76, 144, 108);		SetRect(srcRect[fshBwl], 112, 109, 144, 138);		SetRect(srcRect[66], 144, 109, 160, 125);	{fish 1}		SetRect(srcRect[67], 144, 126, 160, 142);	{fish 2}		SetRect(srcRect[68], 144, 143, 160, 159);	{fish 3}		SetRect(srcRect[69], 144, 160, 160, 176);	{fish 4}		SetRect(srcRect[grease], 112, 139, 144, 168);		SetRect(srcRect[58], 112, 169, 144, 198);	{grease falling 1}		SetRect(srcRect[59], 112, 199, 144, 228);	{grease fallen}		SetRect(srcRect[litSwt], 142, 0, 160, 26);		SetRect(srcRect[thermo], 144, 27, 162, 54);		SetRect(srcRect[outlet], 160, 264, 192, 289);		SetRect(srcRect[51], 160, 290, 192, 315);	{outlet sparking 1}		SetRect(srcRect[52], 160, 316, 192, 341);	{outlet sparking 2}		SetRect(srcRect[pwrSwt], 144, 82, 162, 108);		SetRect(srcRect[guitar], 48, 127, 112, 297);		SetRect(srcRect[drip], 192, 42, 208, 55);		SetRect(srcRect[shelf], 192, 71, 208, 100);		SetRect(srcRect[basket], 448, 270, 511, 341);		SetRect(srcRect[paintg], 408, 53, 510, 146);		SetRect(srcRect[battry], 144, 55, 160, 81);		SetRect(srcRect[macTsh], 256, 209, 301, 267);		SetRect(srcRect[upStar], 0, 0, 161, 254);		SetRect(srcRect[dnStar], 0, 0, 161, 254);		SetRect(srcRect[48], 144, 189, 160, 201);	{candle flame}		SetRect(srcRect[49], 144, 202, 160, 214);	{candle flame}		SetRect(srcRect[50], 144, 215, 160, 227);	{candle flame}		SetRect(srcRect[53], 192, 0, 208, 13);		{drip}		SetRect(srcRect[54], 192, 14, 208, 27);		{drip}		SetRect(srcRect[55], 192, 28, 208, 41);		{drip}		SetRect(srcRect[56], 192, 42, 208, 55);		{drip}		SetRect(srcRect[57], 192, 56, 208, 70);		{drip}		SpinBall;		toolIcnID[0] := 400;		toolIcnID[1] := 401;		toolIcnID[2] := 402;		toolIcnID[3] := 403;		toolIcnID[4] := 404;		toolIcnID[5] := 405;		toolIcnID[6] := 406;		toolIcnID[8] := 408;		toolIcnID[9] := 409;		toolIcnID[10] := 410;		toolIcnID[11] := 411;		toolIcnID[12] := 412;		toolIcnID[13] := 413;		toolIcnID[16] := 416;		toolIcnID[17] := 417;		toolIcnID[18] := 418;		toolIcnID[19] := 419;		toolIcnID[20] := 420;		toolIcnID[21] := 421;		toolIcnID[24] := 424;		toolIcnID[25] := 425;		toolIcnID[26] := 426;		toolIcnID[27] := 427;		toolIcnID[28] := 428;		toolIcnID[29] := 429;		toolIcnID[32] := 432;		toolIcnID[33] := 433;		toolIcnID[34] := 434;		toolIcnID[35] := 435;		toolIcnID[36] := 436;		toolIcnID[37] := 437;		toolIcnID[40] := 440;		toolIcnID[41] := 441;		toolIcnID[42] := 442;		toolIcnID[43] := 443;		toolIcnID[44] := 444;		toolIcnID[45] := 445;		InitCursor;	end;{=================================}end.